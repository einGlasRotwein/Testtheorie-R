
# `data.frames` {#dataframes}

Wir haben gelernt, dass `R` Daten in Vektoren abspeichert. Im Normalfall
haben wir aber in der psychometrischen Datenauswertung eine große Menge
Daten -- also mehr als einen Wert pro "Fall" --, die wir nicht sinnvoll
als einzelnen Vektor darstellen können. Etwa: 150 Studierende bearbeiten
in einer Diagnostikklausur 42 Multiple-Choice-Klausuritems. Wir stellen
solche Daten in Tabellen dar, wie wir sie auch aus Excel oder SPSS
kennen. In solchen Tabellen repräsentieren Spalten Messwerte, etwa die
Punktzahlen in einer Klausuraufgabe. Zeilen stellen Fälle dar. Ein Fall
könnte etwa eine Testteilnehmerin sein, für die in mehreren Spalten ihre
Punktzahlen in allen Aufgaben abgespeichert sind.[^`r incref()`] In `R`
werden solche Datentabellen in `data.frames` abgespeichert. Ein
`data.frame` ist -- vereinfacht gesagt -- eine Sammlung von Vektoren;
jede Spalte, also jede Messvariable, ist ein Vektor.

[^`r incfnc()`]: Andere Formate sind auch denkbar, etwa eines in dem
jede Zeile eine Aufgabe darstellt. Bei uns wird aber im Normalfall
gelten: eine Zeile entspricht einem Fall -- oftmals einer Person.

## Die Funktion `data.frame`

Mit der Funktion `data.frame` kann ich "händisch" einen `data.frame`
erstellen. In der Praxis werden wir das aber wohl nur selten machen und
stattdessen Daten aus einer externen Datei einlesen.[^`r incref()`] Die
folgende unscheinbare Tabelle mit 5 Einträgen erstelle ich mit der
Funktion `data.frame`; sie wird uns durch einen Großteil des Kapitels
begleiten, um Grundlagen von `data.frame`-Operationen zu betrachten.

[^`r incfnc()`]: Beispielsweise können die Daten in einem
*Spreadsheet-Editor* wie Excel eingegeben worden sein und wir
importieren diese dann in `R`.

```{r}
 mdf <- data.frame(Nummer = 1:5,
                   Item1 = c(1, 0, 0, 1, 1),
                   Item2 = c(1, 1, 0, 0, 1),
                   Alter = c(13, 14, 13, 12, 15),
                   Geschlecht = c("w", "m", "m", "w", "m")
                   )
mdf
```

Wir sehen, dass der `data.frame` -- ebenso wie es bei Vektoren möglich
war -- in einer Variable gespeichert wird. Die Variable zum Abspeichern
des `data.frames` nenne ich in diesem Fall `dfw`; das könnte
beispielsweise für "Mein Data-Frame" stehen. Bei der Erstellung des
`data.frames` wird deutlich, dass Spalten Vektoren enthalten, da wir für
jede Spalte einen Vektor mit der Funktion `c` bzw. mit dem
Doppelpunktoperator erstellen. Wir sehen auch, dass die Spalten bei der
Erstellung des `data.frames` benannt werden können. **Dieser Punkt ist
sehr wichtig, da wir Spalten anhand ihres Namens gezielt auswählen
werden**. Wenn ich die Spaltennamen, also die Namen der Messvariablen
eines `data.frames` nicht weiß -- etwa weil ich die Daten aus einer
Datei eingelesen habe -- kann ich diese mit der Funktion `names`
herausfinden:

```{r}
names(mdf)
```

## Datenzugriffe

Wir lernen in diesem Abschnitt die wichtigsten Möglichkeiten kennen,
Daten aus Spalten und Zeilen von `data.frames` auszuwählen.

### Zugriff auf eine einzelne Spalte: die `$`-Notation

Der `$`-Zugriff ist für uns die grundlegendste Operation auf
`data.frames`. Mit der `$`-Notation können wir auf eine einzelne Spalte
eines `data.frames` zugreifen und diese **als Vektor** auslesen:

```{r}
punkte <- mdf$Item1
punkte # `punkte` ist ein Vektor
```

Ich kann den `$`-Zugriff nicht nur verwenden, um eine Spalte aus einem
`data.frame` auszulesen, sondern kann damit auch neue Spalten zum
`data.frame` hinzufügen. Das geht, indem ich der neu zu erstellenden
Spalte per "`<-`" einen Vektor zuweise:

```{r}
mdf$Augenfarbe <- c("blau", "grau", "blau", "braun", "grün")
```

```{r}
mdf
```

Beim Anhängen von Spalten an `data.frames` mit der `$`-Notation kann ich
jegliche Berechnungsvorschriften für Vektoren verwenden. So kann ich
etwa einen Testscore über zwei Items berechnen und direkt an den
`data.frame` anhängen:

```{r}

mdf$Testscore <- mdf$Item1 + mdf$Item2

mdf$Testscore

```

Beachtet, dass in diesem Fall recht häufig die `$`-Notation zum Einsatz
kommt, was etwas gewöhnungsbedürftig aussieht. Aber es ist wichtig
darauf zu achten. Die Variablen,[^`r incref()`] die wir in diesem
Beispiel verwenden, um den Testscore zu berechnen "wohnen" in
`mdf` und können nicht ohne Verweis darauf adressiert
werden. Das hier geht schief:

[^`r incfnc()`]: Es ist etwas unglücklich, dass der Begriff "Variable"
eine doppeldeutige Verwendung hat: (1) In `R` sind Variablen die
Speicherorte von Objekten, die ich mit der "`<-`" Zuweisung erstelle.
(2) Andererseits bezeichnet man auch Messwerte, etwa die Punktzahlen in
einem Testitem, als Variable. In `R` würde man sich bei dieser
Verwendung des Begriffs Variable dann auf die Spalte in einem
`data.frame` beziehen. Diese Verwechslung ist unglücklich, da eine
`data.frame` Spalte gar keine `R`-Variable ist. Stattdessen speichern
wir den gesamten `data.frame` in **einer** Variablen ab.

```R
mdf$Testscore <- Item1 + Item2
Fehler: Objekt 'Item1' nicht gefunden
```

Hier sucht `R` nach einer Variablen `Item1`, die aber nicht existiert;
`Item1` ist nur eine Spalte von `mdf`. Noch schlimmer wäre es,
wenn in meiner Arbeitsumgebung tatsächlich Variablen mit den Namen
`Item1` und `Item2` existieren. In dem Fall würden wir nicht einmal eine
Fehlermeldung erhalten[^`r incref()`] und hätten gegebenenfalls falsche
Daten abgespeichert.

[^`r incfnc()`]: Wir können uns schon einmal merken, dass
Fehlermeldungen grundsätzlich etwas Gutes sind. Auch wenn sie oft
frustrierend sind, helfen sie uns dabei, korrekten Code zu schreiben.

Mit der `$`-Notation werden wir häufig auf Daten zugreifen, um
Berechnungen anzustellen. Wir können beispielsweise Mittelwerte von
Messvariablen berechnen, oder uns Häufigkeiten von Daten angeben lassen:

```{r}
mean(mdf$Alter)
table(mdf$Geschlecht)
```

Die Funktion `mean` kennen wir bereits. Die Funktion `table` berechnet
die Häufigkeiten von Werten, die in Vektoren vorkommen. Sie ist vor
allem nützlich, um kategorielle Messvariablen zu beschreiben. Zur
Überprüfung der Plausibilität von Daten ist `table` extrem
nützlich. (Ist jeder Wert ein "legaler" Wert, der auch vorkommen
sollte?) Ich kann die Funktion `table` auch verwenden, um die Häufigkeit
der Kombination von mehreren Variablen zu erfragen, etwa wie häufig
welcher Testscore nach Geschlecht auftaucht:

```{r}
## Erstelle Kreuztabelle von Geschlecht und Augenfarbe:
table(mdf$Augenfarbe, mdf$Geschlecht)
```

### Zugriff auf Spalten und Zeilen: die `[·,·]`-Notation

Einzelne Spalten können wir aus `data.frames` mit dem `$`-Zugriff
auslesen. Wir lernen nun den `[·,·]`-Zugriff kennen, mit dem wir nicht
nur einzelne Spalten, sondern beliebige Spalten und Zeilen auswählen
können.[^`r incref()`] Wie wir sehen werden, funktioniert der
`[·,·]`-Zugriff ähnlich wie der `[·]`-Zugriff, den wir zur Auswahl von
Daten aus Vektoren kennengelernt haben.

[^`r incfnc()`]: Während uns der `$`-Zugriff uns immer genau einen
Vektor zurückgibt, werden wir mit dem `[·,·]`-Zugriff **zumeist** einen
ganzen `data.frame` auslesen.

Mit dem `[·,·]`-Zugriff könnten wir beispielsweise nur eine Teilmenge
aller Fälle aus `mdf` auswählen; etwa nur die Personen mit blauen Augen,
oder alle Personen, die den maximalen Testwert erreicht haben. Für
solche Auswahlen hilft uns unser Wissen über logische Vergleiche aus dem
letzten Kapitel. Betrachten wir zunächst ein Beispiel:[^`r incref()`]

[^`r incfnc()`]: Beachtet, dass durch diesen Aufruf der `data.frame`,
der in der Variablen `mdf` abgespeichert ist, nicht verändert wird. Der
`[·,·]`-Zugriff gibt stattdessen einen neuen `data.frame` zurück, der
nur die Fälle enthält, bei denen `mdf$Augenfarbe == "blau"` `TRUE`
ergibt. Wir müssten das Ergebnis der Funktion in einer Variablen
speichern, wenn wir damit weiter arbeiten wollen (Erinnerung: [Kapitel
2](#ausgabevsabspeichern)).

```{r}
mdf[mdf$Augenfarbe == "blau", ]
```

Wie das folgende Beispiel zeigt, können wir mit der `[·,·]`-Notation
auch gezielt Spalten aus `data.frames` auswählen:

```{r}
mdf[, c("Augenfarbe", "Alter")]
```

Wir erkennen, dass das Komma in der `[·,·]`-Notation bewirkt, ob eine
Auswahl nach Zeilen oder Spalten stattfindet. **Vor dem Komma werden
Zeilen adressiert, nach dem Komma Spalten.** Allgemein ist die Syntax
zum Ansprechen von `data.frames` mit dem `[·,·]`-Zugriff die Folgende:

```
data.frame[Reihenvektor, Spaltenvektor]
```

Dabei ist *Reihenvektor*/*Spaltenvektor* entweder ein (a) numerischer
Vektor, der die Indexe der Reihen/Spalten enthält, die ausgewählt werden
sollen, (b) ein logischer Vektor, der für jede Reihe/Spalte kodiert, ob
diese in der Ausgabe enthalten sein soll (vgl. Kapitel
[2](#logischerZugriff)), oder (c) Vektor vom Typ `character`, der die
Namen der Zeilen/Spalten enthält, die ausgegeben werden sollen.
[^`r incref()`]

[^`r incfnc()`]: Auch Zeilen können benannt sein. Den Fall hatten wir
bislang aber nicht und es ist auch nicht häufig so, dass Zeilen explizit
benannt sind.

Es ist möglich, dass in einem einzelnen `[·,·]`-Zugriff sowohl nach
Spalten als auch Zeilen ausgewählt wird. Oftmals wird aber entweder der
Spaltenvektor oder der Reihenvektor "leer" sein. Dann findet die Auswahl
nur entweder nach Zeilen beziehungsweise Spalten statt, wie es auch in
den obigen Beispielen der Fall war.

Häufig werden wir zur Auswahl der gewünschten Spalten einen Vektor vom
Typ `character` angeben -- also die Spaltennamen. Zur Auswahl von Zeilen
wird man häufig einen logischen Vektor verwenden, der die Eigenschaften
der Fälle kodiert, die die auszuwählenden Fälle haben sollen. Aber: Alle
Möglichkeiten sind denkbar, etwa auch, dass ein logischer Vektor zur
Auswahl der Spalten verwendet wird oder wir die Nummern der Zeilen
angeben, die ausgewählt werden sollen.

Durch die UND bzw. ODER Operationen können wir auch komplexere
Anforderungen an die Auswahl der Zeilen stellen:

```{r}
mdf[mdf$Augenfarbe == "blau" | mdf$Augenfarbe == "grün", ]
mdf[mdf$Augenfarbe == "blau" | mdf$Augenfarbe == "grün" & mdf$Item1 == 1, ]
```

Hier merken wir, dass die `[·,·]`-Notation recht schnell unübersichtlich
wird, wenn man komplexere logische Anfragen stellt. Insbesondere führen
wir hier häufig einen `$`-Zugriff auf `dfw` durch, um die kombinierte
logische Bedingung anzugeben. Weiter unten lernen wir mit der Funktion
`subset` eine Möglichkeit kennen, komplexere logische Anfragen an die
Auswahl von Zeilen etwas prägnanter zu stellen.

Zum Abschluss dieses Abschnitts betrachten wir noch einige weitere
Beispiele für die verschiedenen Auswahlmöglichkeiten per `[·,·]`:

```{r}
## Wähle per Index die ersten drei Zeilen aus
mdf[1:3, ]

## Wähle per Index die zweite und vierte Spalte aus
mdf[, c(2, 4)]

## Wähle per logischem Vektor alle Personen aus, die beide Aufgaben
## richtig gelöst haben:
mdf[mdf$Testscore == 2, ]

## Wähle alle Personen aus, die blaue oder braune Augen haben:
mdf[mdf$Augenfarbe == "blau" | mdf$Augenfarbe == "braun", ]

## Wähle Fallnummer, Alter und Testscore per Spaltenname aus:
mdf[, c("Nummer", "Alter", "Testscore")]

## Wähle Fallnummer, Alter und Testscore aus für alle Personen, die
## älter als 13 sind
mdf[mdf$Alter > 13, c("Nummer", "Alter", "Testscore")]

## Wähle Fallnummer, Alter und Testscore aus für die ersten drei Fälle
mdf[1:3, c("Nummer", "Alter", "Testscore")]

## Wähle die Itemscores aus - nutze dabei die Funktion paste0
mdf[, paste0("Item", 1:2)]

```

```{block, type = "block"}
**Merke**: Mit dem `[·,·]` Zugriff wird zuerst -- vor dem Komma -- die
Reihe und dann -- nach dem Komma -- die Spalte adressiert. Man kann die
Auswahl nach numerischem Index, mit einem logischen Vektor, oder mit
einem `character` Vektor durchführen.
```

### Weitere Zugriffsmöglichkeiten auf Spalten

Dieser Abschnitt behandelt zwei weitere Varianten des Datenzugriffs auf
`data.frames` mithilfe eckiger Klammern. Da wir diese Zugriffe danach
erst einmal nicht weiter verwenden, kann dieser Abschnitt jedoch
zunächst problemlos übersprungen werden. Datenzugriffe mit eckigen
Klammern sind jedoch zentral für `R` als Programmiersprache, weswegen es
sich lohnt diesen Abschnitt später zu konsultieren oder zum Nachschlagen
zu nutzen.

**Der `[[·]]`-Zugriff**

Äquivalent zum `$`-Zugriff funktioniert der folgende
`[[·]]`-Zugriff auf eine einzelne Spalte:

```{r}
mdf[["Item1"]] # dasselbe wie mdf$Item1
```

Hierbei wird der Spaltenname als ein-elementiger Vektor vom Typ
`character` -- also mit Anführungszeichen -- angegeben. Die
Anführungszeichen sind notwendig, wenn man die `[[·]]`-Notation
verwendet. Bei der `$`-Notation verwenden wir keine Anführungszeichen.
Das bedeutet auch, dass wir statt der expliziten Angabe des Texts auch
eine Variable übergeben kann, die einen ein-elementigen
`character`-Vektor abspeichert, was mit der `$`-Notation nicht möglich
ist.

```{r}
auswahl <- "Augenfarbe"
mdf[[auswahl]]
```

Es ist auch möglich, eine Funktion in die `[[·]]`-Klammerung zu
übergeben, die uns einen ein-elementigen Vektor vom Typ character
zurückgibt -- etwa die Funktion `paste0`:

```{r}
mdf[[paste0("Item", 1)]]
```

Dieser Zugriff wird für uns noch einmal interessant werden, da wir so
mithilfe von *Schleifen*[^`r incref()`] (in Kapitel 6) in `data.frames`
nacheinander auf beliebig viele Spalten zugreifen können. Dabei wird es
vor allem interessant sein, nacheinander auf die Antworten auf Testitems
(Item **1**, Item **2**, ...) zuzugreifen.

[^`r incfnc()`]: In einer Schleife können wir dann den numerischen Wert
-- hier `1` -- nacheinander immer wieder austauschen (1, 2, 3, 4, ...)
-- ohne, dass wir den Code immer wieder händisch neu schreiben müssen.

**Der `[·]`-Zugriff**

**Nicht** äquivalent zu den Zugriffen mit `$` und `[[·]]` ist
folgender `[·]`-Zugriff:

```{r}
mdf["Item1"]
```

Auch hier sind Anführungszeichen zur Identifikation der auszuwählenden
Spalte nötig. Der Unterschied von `[·]` zu `[[·]]` und `$`: `[[·]]` und
`$` ergeben einen Vektor, `[·]` einen `data.frame` mit einer Spalte.
Außerdem können wir mit dem `[·]`-Zugriff -- im Gegensatz zu den
Zugriffen per `[[·]]` und `$` -- gleichzeitig mehrere Spalten auswählen,
indem wir einen mehr-elementigen Vektor vom Typ `character` angeben:

```{r}
mdf[c("Item1", "Augenfarbe")]
```

Dieser Aufruf sollte uns an die `[·,·]`-Notation zur Auswahl von Spalten
erinnern; in der Tat ist dieser Ausdruck äquivalent zum folgenden
Befehl:

```{r}
mdf[, c("Item1", "Augenfarbe")]
```

Zwischen dem `[·]`-Zugriff und der `[·,·]`-Auswahl für Spalten gibt es
jedoch einen Unterschied, der zutage kommt, wenn wir nur eine Spalte
auswählen:

```{r}
mdf["Item1"]
```

```{r}
mdf[, "Item1"]
```

Hier gibt die `[·,·]`-Auswahl einen Vektor zurück und die `[·]`-Auswahl
einen `data.frame` mit nur einer Spalte. So lernen wir einen Sonderfall
der `[·,·]`-Auswahl kennen: Im Normalfall erhalten wir einen ganzen
`data.frame` zurück, wenn wir per `[·,·]` Daten anfordern. Wenn wir aber
nur eine Spalte anfordern, "reduziert" sich die Ausgabe zu einem Vektor.
Das liegt daran, dass eine einzelne Spalte eines `data.frame` auch gut
als Vektor repräsentiert ist.

### Zugriff auf Spalten und Zeilen: die Funktion `subset` {#subset}

**Ideen für Restrukturierung**

- subset = Abstraktion wichtiger Nutzungen von [·,·]: Spaltenauswahl per
  Spaltenname, Zeilenauswahl per logischem Ausdruck
- Dafür: Zeilenauswahl per logischem Ausdruck, Spaltenauswahl wie gehabt,
  aber mit Sonderregeln, die die Auswahl etwas vereinfachen
- Außerdem in diesem Abschnitt: Erklärung einiger allgemeiner Regeln
  zu Funktionen in R



Einzelne Spalten aus `data.frames` können wir mit dem `$`-Zugriff
auslesen. Wir lernen nun die Funktion `subset`[^`r incref()`] kennen,
mit der wir bequem beliebige Spalten und Zeilen aus `data.frames`
auswählen können. Anders als bei der Auswahl mit dem `$`-Operator --
dessen Rückgabe ein Vektor ist --, gibt uns die Funktion `subset` immer
einen ganzen `data.frame` zurück.

[^`r incfnc()`]: Der Abschnitt zur Funktion `subset` ist ein besonders
wichtiger Abschnitt, da hier nicht nur die spezielle Funktionalität
einer einzelnen Funktion erläutert wird, sondern auch an ihrem Beispiel
allgemeine Eigenschaften von Funktionen in `R` dargestellt werden.

Mit `subset` können wir beispielsweise nur eine Teilmenge aller Fälle
auswählen; etwa nur die Personen mit blauen Augen. Für diese Auswahl
hilft uns unser Wissen über logische Vergleiche aus dem letzten
Kapitel:[^`r incref()`]

[^`r incfnc()`]: Beachtet, dass durch diesen Aufruf die Tabelle
`mdf` nicht verändert wird. Die Funktion gibt stattdessen eine
neue Tabelle zurück, die nur die Fälle enthält, bei denen
`Augenfarbe == "blau"` gilt. Wir müssten das Ergebnis der Funktion in
einer Variablen speichern, wenn wir damit weiter arbeiten wollen
(Erinnerung: [Kapitel 2](#ausgabevsabspeichern)).

```{r}
subset(mdf, Augenfarbe == "blau")
```

Auf diese Weise haben wir mit einem logischen Vergleich aus der Tabelle
nur zwei Zeilen ausgewählt. Ihr merkt: In der Funktion `subset` kann ich
für die logische Auswahl nach Augenfarbe die Spalte `Augenfarbe` direkt
mit ihrem Namen adressieren, ohne dass ich die `$`-Notation
verwende. Das ist eine Besonderheit der Funktion `subset`; außerhalb der
Funktion würde der Befehl `Augenfarbe == "blau"` einen Fehler ausgeben,
da `Augenfarbe` selbst keine Variable ist -- nur eine Spalte von
`mdf`.[^`r incref()`] Innerhalb der Funktion `subset`
funktioniert es nur deswegen, da das erste Argument der `data.frame`
ist, aus dem ich Daten auswähle. Die Funktion `subset` weiß somit, auf
welchen Daten sie operieren muss. Das Folgende ist also nicht nötig,
obwohl es auch funktionieren würde:

[^`r incfnc()`]: Es macht an dieser Stelle Sinn, einen Moment inne zu
halten und zu überlegen, warum es eigentlich außergewöhnlich ist, dass
der Befehl `Augenfarbe == "blau"` innerhalb der Funktion `subset`
funktioniert.

```R
subset(mdf, mdf$Augenfarbe == "blau")
```

Dementsprechend könnte man auch der Funktion `subset` -- dieses
Verhalten kennen wir von der `[·]`-Notation zur Auswahl von Elementen
aus Vektoren -- einen beliebigen logischen Vektor zur Auswahl der Zeilen
übergeben:

```{r}
subset(mdf, c(TRUE, FALSE, FALSE, TRUE, FALSE)) # wählt die erste und vierte Zeile aus
```

Durch die UND bzw. ODER Operationen können wir auch komplexere
Anforderungen an die Auswahl stellen:

```{r}
subset(mdf, Augenfarbe == "blau" | Augenfarbe == "grün")

subset(mdf, (Augenfarbe == "blau" | Augenfarbe == "grün") & Item1 == 1)

```

Wie schon erwähnt, können wir mit `subset` nicht nur Zeilen, sondern
auch Spalten auswählen:

```{r}
subset(mdf, Augenfarbe == "blau", c("Item1", "Augenfarbe"))
```

Hierbei habe ich mit dem dritten Argument `c('Item1', 'Augenfarbe')`
eine Auswahl der Spalten durchgeführt. Dazu habe ich einen Vektor vom
Typ `character` übergeben, der die auszulesenden Spalten mit Namen
adressiert. Durch die Kombination der Auswahl von Zeilen und Spalten
wird mir insgesamt ein `data.frame` ausgegeben, der nur die Spalten
"Item1" und "Augenfarbe" enthält, und diese nur für Personen mit blauen
Augen.

```{block, type = "block"}
**Merke**: Die Funktion `subset` gibt immer einen ganzen `data.frame`
zurück -- selbst dann, wenn ich nur eine einzige Spalte anfordere. Mit
dem `$`-Operator könnte ich hingegen eine einzelne Spalte als Vektor
auslesen.
```

Bei dieser Verwendung der Funktion `subset` fällt eine allgemeine
Eigenschaft von Funktionen auf: `subset` erkennt anhand der Reihenfolge
der Argumente, wie sie sich zu verhalten hat. Das erste Argument
übergibt den `data.frame`, von dem wir Daten anfordern. Das zweite
Argument wählt mit einem logischen Ausdruck **Zeilen** aus, das dritte
Argument wählt durch einem `character`-Vektor **Spalten** aus. Was
passiert, wenn wir diese Reihenfolge ändern?

```R
subset(mdf, c("Item1", "Augenfarbe"),
       Augenfarbe == "blau")
```

```
Fehler in subset.data.frame(mdf,
c("Item1", "Augenfarbe"), Augenfarbe ==  : 'subset' muss
boolesch sein
```

Hier erhalten wir eine schwierig zu verstehende Fehlermeldung. Aber uns
ist der Fehler klar: das zweite Argument von `subset` muss die Auswahl
der Zeilen beschreiben, wir haben aber stattdessen einen
`character`-Vektor übergeben, der die Spalten auswählen sollte. Was
können wir machen, wenn wir **nur** eine Auswahl nach Spalte ausführen
wollen? Wir können das zweite Argument ja nicht leer lassen, denn das
führt zum obigen Fehler.

Dieses Problem lässt sich mit einer praktischen Eigenschaft der
`R`-Sprache lösen: **In `R` haben die Argumente von Funktionen Namen.**
Bislang haben wir das ignoriert bzw. nur am Rande mitbekommen (erinnern
wir uns an das Argument `na.rm` der Funktion `mean`).

Die Funktion `subset` hat die folgenden drei benannten Argumente:

- `x`: der Datensatz, aus dem ausgewählt wird
- `subset`: die Auswahl der Zeilen
- `select`: die Auswahl der Spalten

Um eine Übersicht über die verschiedenen Argumente einer Funktion zu
erhalten, können wir die eingebaute Hilfe von `R` verwenden, die wir mit
dem `?`-Operator erhalten. Wir verwenden sie wie folgt:

```R
?subset
```

Die `R`-Hilfe informiert uns unter anderem über die Argumente, die
Funktionen annehmen können. Leider ist diese Hilfe oftmals kryptisch --
und das nicht nur für Anfänger. Sie ist die offizielle Dokumentation von
Funktionen und legt deswegen zwar großen Wert auf technische
Genauigkeit, ist aber nicht immer sonderlich ausführlich oder gar
verständlich. Wir werden in Kapitel 5 bei einer ausführlicheren
Besprechung von Funktionen noch einmal darauf zurückkommen, wie wir mit
der Hilfe-Funktion umgehen können.

Wenn wir die verschiedenen Argumente der Funktion `subset` kennen,
können wir sie auch mit der folgenden Notation ausführen:

```{r}
subset(x = mdf, subset = Augenfarbe == "blau",
       select = c("Item1", "Augenfarbe"))
```

Hierbei benennen wir die Argumente, die wir nutzen, explizit.  Wie wir
es schon beim Argument `na.rm` der Funktion `mean` kennengelernt haben,
können wir Argumente mit der Schreibweise "`Funktionsargument = Wert`"
adressieren. "`Wert`" ist dabei immer ein `R`-Objekt,
"`Funktionsargument`" der Name des Arguments. Im Fall von `subset`
nehmen die drei Argumente folgende Objekte an:[^`r incref()`]

[^`r incfnc()`]: Die Funktion `subset` lässt hier ein paar Ausnahmen zu,
die weiter unten besprochen werden. Die erste Ausnahme kennen wir schon:
Das Argument `subset` akzeptiert auch, wenn wir einen Ausdruck
übergeben, der außerhalb der Funktion gar nicht als logischer Vektor
erkannt würde.

1. `x`: einen `data.frame`
2. `subset`: einen logischer Vektor
3. `select`: einen Vektor vom Typ `character`

Wenn ich Funktionsargumente mit Namen adressiere, kann ich die
Reihenfolge, in der ich sie der Funktion übergebe, beliebig
vertauschen. Dieser Aufruf etwa ist äquivalent (d.h. führt zur selben
Ausgabe) wie der obige Aufruf:


```R
subset(select = c("Item1", "Augenfarbe"),
       subset = Augenfarbe == "blau", x = mdf)
```


```{r, echo = FALSE}
## doppelter Code wegen Formatierung =/
subset(select = c("Item1", "Augenfarbe"),
       subset = Augenfarbe == "blau", x = mdf)
```

In `R` kann man **fast immer**[^`r incref()`] Argumente per Position und
per Name ansprechen. Oftmals wollen wir die Namen von Funktionen
explizit verwenden, da viele Funktionen *optionale* Argumente haben --
also solche, die wir nicht immer angeben müssen. Wir können ja
beispielsweise das Argument `select` weglassen, wenn wir nach Zeilen,
aber nicht nach Spalten selegieren wollen. Analog muss ich nicht das
Argument `subset` angeben -- in dem Fall werden alle Zeilen ausgegeben,
aber nur eine Teilmenge der Spalten, wie in diesem Beispiel:

[^`r incfnc()`]: Eine Ausnahme bildet hier die Funktion `c`, bei der wir
keine Funktionsnamen angeben. Hier gilt nämlich: wir können beliebig
viele Vektoren als Argumente angeben und deswegen gibt es natürlich
keinen separaten Namen für jedes mögliche Argument. Feste Namen gibt es
aber normalerweise, wenn es eine feste Anzahl an möglichen Argumenten
gibt -- wie bei der Funktion `subset`.

```{r}
subset(mdf, select = c("Testscore", "Geschlecht"))
```

Mit diesem Aufruf werden mir alle 5 Fälle zurückgegeben, aber für diese
nur der Testscore und das Geschlecht. Wie dieser Aufruf zeigt, kann ich
Auswahl nach Position und Auswahl nach Namen mischen. Für das erste
Argument -- `mdf` -- habe ich den Argumentnamen `x` nicht
angegeben. Daher wurde das Argument anhand der Position
identifiziert. Das hat funktioniert, da das erste Argument der
`data.frame` ist, aus dem die Datenauswahl stattfindet. Für die Auswahl
der Spalten habe ich jedoch den Argumentnamen angegeben. **Das war auch
nötig**, da `subset` als zweites Argument sonst die Auswahl der Zeilen
erwartet hätte.

```{block, type = "block"}
**Merke**: In `R` können Funktionsargumente per Position und per Namen
identifiziert werden. Die Identifikation per Name schlägt dabei die
Identifikation per Position.
```

**Ausnahmeregeln für die Funktion `subset`**

Inhalt folgt.

### Zugriff nach Name und Index {#nameindex}

Nachdem die Möglichkeiten zum Zugriff auf `data.frames` besprochen sind,
stellen wir zum Abschluss ein grundsätzliches Prinzip zu Datenzugriffen
in `R` fest: Man kann Zugriffe -- seien es Vektoren, `data.frames` oder
auch andere Strukturen, die wir noch gar nicht behandelt haben -- **nach
Index oder nach Name** durchführen. Wir haben bereits Beispiele für
beides kennengelernt: In Vektoren haben wir Zugriffe mithilfe von
Indexen durchgeführt, indem wir (a) die Position von auszuwählenden
Elementen explizit mit einem numerischen Vektor angegeben haben, oder
(b) indem wir einen logischen Vektor übergeben haben, der anhand von
`TRUE` und `FALSE` Werten die Indexe auswählt, deren Elemente ausgegeben
werden sollen. Der Vollständigkeit halber sei hier mitgeteilt, dass man
sogar bei Vektoren Zugriffe nach Namen durchführen kann, wenn die
Elemente des Vektors benannt sind. Das ist gar nicht so ungewöhnlich;
wie folgt könnte man einen Vektor mit benannten Elementen erstellen und
mit der bekannten `[·]`-Notation darauf zugreifen.

```{r}

## Benannte Vektoren erstellen funktioniert wie einen data.frame zu
## erstellen:
vec <- c(foo = 1, bar = 2)
vec

vec["foo"]
vec["bar"]
vec[c("bar", "foo")]

```

In `data.frames` haben wir Spalten zumeist nach Namen ausgewählt:
- Mit der `$`-Notation
- Mit der `[·,·]`-Notation
- Mit der Funktion `subset`
- Mit der `[[·]]`-Notation
- Mit der `[·]`-Notation

 Mit der `[·,·]`-Notation können wir in `data.frames` zusätzlich auch
 Zugriffe nach numerischem oder logischen Index durchführen, wie wir
 gesehen haben. Dabei kann die Auswahl sowohl nach Spalten als auch nach
 Zeilen -- oder beidem -- geschehen.

## Nützliche Funktionen zum Arbeiten mit `data.frames` {#convenient}


### `tapply` {#tapply}

Die Funktion `tapply` kann ich verwenden, um mir deskriptive
Statistiken anhand von Gruppierungsvariablen ausgeben zu lassen, hier
etwa die mittlere Punktzahl oder das mittlere Alter nach Geschlecht der
Schüler/innen:

```{r}
tapply(mdf$Testscore, mdf$Geschlecht, mean)
tapply(mdf$Alter, mdf$Geschlecht, mean)
```

Die Funktion `tapply` erhält als erstes Argument den Messwertvektor, für
den Statistiken angefordert werden. Das zweite Argument ist die
Gruppierungsvariable.[^`r incref()`] Interessanterweise ist das dritte
Argument eine Funktion, in diesem Fall die Funktion `mean`. So können
wir die *mittlere* Punktzahl nach Geschlecht anfordern. Entsprechend
könnten wir hier andere Funktionen übergeben, um etwa die
Standardabweichung des Alters zu erfragen:

[^`r incfnc()`]: Beachtet, dass sowohl Messwerte als auch
Gruppierungsvariable als **Vektoren** übergeben werden. Ich behandle die
Funktion `tapply` jedoch im Kapitel zu `data.frames`, da es zumeist so
sein wird, dass wir beide Vektoren aus **einem** `data.frame` mit der
`$`-Notation auslesen werden.

```{r}
tapply(mdf$Alter, mdf$Geschlecht, sd)
```

Wie `table` kann auch `tapply` deskriptive Statistiken anhand mehrerer
Gruppierungsvariablen anfordern. Um mehrere Gruppierungsvariablen
anzufordern, klammern wir `list(...)` um die Gruppierungsvektoren im
zweiten Argument:

```{r}
tapply(mdf$Alter, list(mdf$Geschlecht, mdf$Augenfarbe), mean)
```

Mit nur fünf Datenpunkten macht diese Anfrage hier nur wenig Sinn, da
jeder ausgegebene Mittelwert nur anhand eines einzelnen Wertes gebildet
wurde,[^`r incref()`] was die Idee des Mittelwerts eher ad absurdum
führt. Manche Kombinationen von Geschlecht und Augenfarbe kommen in
unseren Daten sogar gar nicht vor; in diesen Fällen wird `NA`
ausgegeben. `tapply` zeigt ihre Stärke vor allem, wenn man viele -- und
nicht nur 5 -- Datenpunkte hat. Das gilt gerade dann, wenn wir mehrere
Gruppierungsvariablen angeben.

[^`r incfnc()`]: Wie viele Datenpunkte in die Berechnung jedes
Mittelwerts eingehen, können wir in diesem Fall prüfen mit
`table(mdf$Geschlecht, mdf$Augenfarbe)`.

### `nrow` und `ncol`

Die Zahl der Zeilen eines `data.frame`s -- d.h. oftmals die Zahl der
*Fälle* -- lässt sich mit der Funktion `nrow` bestimmen, die man sehr
häufig verwendet:

```{r}
nrow(mdf)
```

Analog ergibt `ncol` die Zahl der Spalten:

```{r}
ncol(mdf)
```

### `head` und `tail`

Um sich einen Überblick über einen `data.frame` zu verschaffen, sind die
Funktionen `head` und `tail` sehr nützlich. `head` gibt die ersten
Zeilen eines `data.frames` zurück, `tail` entsprechend die letzten
Zeilen. Beide Funktionen haben ein zweites Argument *n*, welches wir
nutzen können, um zu steuern, wie viele Zeilen ausgegeben werden
sollen. Wenn wir *n* nicht angeben, werden 6 Zeilen ausgegeben (in
`R`-Jargon: 6 ist der "default"-, also Standardwert des *optionalen
Arguments* n). Beispiel:

```{r}
head(mdf, n = 2)
tail(mdf)
```

Im letzteren Fall werden einfach alle Zeilen zurückgegeben, da unser
`data.frame` insgesamt nur fünf Zeilen hat -- und somit weniger als 6.

### Sortieren: `dplyr::arrange`

Oftmals wollen wir Datentabellen nach einer oder mehreren Variablen
sortieren. Dies funktioniert am bequemsten, wenn wir das *Paket* `dplyr`
laden [@R-dplyr]:

```{r}
library("dplyr")
```

Voraussetzung dafür, dass ich das Paket `dplyr` nutzen kann ist, dass
ich das Paket auf meinem Rechner installiert habe. Falls das Paket noch
nicht installiert ist (in dem Fall ergibt der Befehl `library('dyplr')`
einen Fehler) , könnte ich es mit dem folgenden Befehl installieren:

```R
install.packages("dplyr")
```

Pakete stellen zusätzliche Funktionen zur Verfügung, die in der
Basisversion von `R` nicht enthalten sind. Um ein Paket zu nutzen,
müssen wir es mit der Funktion `library` in unsere `R`-Umgebung laden.
Andernfalls könnten wir die Funktionen nicht nutzen, die etwa `dplyr`
enthält. Die Funktion `arrange` aus `dplyr` ermöglicht es uns, einen
`data.frame` zu sortieren:

```{r}
arrange(mdf, Testscore) # dplyr muss geladen sein
```

In der Funktion `arrange` geben wir als erstes Argument den zu
sortierenden `data.frame` an. Darauf folgen -- mit Komma separiert --
alle Spalten nach denen wir sortieren wollen (hier erst mal nur der
Testscore). Standardmäßig sortiert `arrange` *aufsteigend*, wenn wir
eine absteigende Sortierung wünschen, müssen wir ein Minus vor die
Sortierspalte setzen:

```{r}
arrange(mdf, -Testscore)
```

Es ist auch möglich, nach mehreren Spalten zu sortieren. In dem Fall
wird bei gleichen Werten im ersten Sortierkriterium anhand des nächsten
Kriteriums die Reihenfolge entschieden. Wir könnten etwa unsere Daten
nach Geschlecht sortieren, und innerhalb der Personen gleichen
Geschlechts nach Punktzahl:

```{r}
arrange(mdf, Geschlecht, -Testscore)
```

## Zusammenfassung

- Wir haben den `data.frame` als Datenstruktur zur Speicherung von
  psychometrischen Daten kennengelernt
- Wir haben den Zugriff auf Spalten und Zeilen in `data.frames` mit der
  `$`-Notation und der Funktion `subset` kennengelernt
- Zur Anforderung von deskriptiven Statistiken können wir die Funktionen
  `table` und `tapply` verwenden
- Wir haben weitere Funktionen kennengelernt, die uns einen Überblick
  über `data.frames` verschaffen:
    + `names`
    + `nrow/ncol`
    + `head/tail`
    + `dplyr::arrange`

## Fragen zum vertiefenden Verständnis

1. Worin unterscheiden sich die folgenden Aufrufe? Welche Aufrufe sind
   zueinander äquivalent?

```R
subset(mdf, select = "Item1")
```

```R
mdf[, "Item1"]
```

```R
mdf[, "Item1", drop = FALSE]
```

```R
mdf[["Item1"]]
```

```R
mdf$Item1
```

2. Vergleicht die folgenden Aufrufe der Funktion `subset`. Warum
   funktionieren der erste und der zweite Aufruf, aber nicht der dritte
   und vierte?  Wie kann es überhaupt sein, dass die ersten beiden
   Funktionsaufrufe funktionieren, obwohl Argumente unbenannt an der
   "falschen" Position stehen?

```R
subset(mdf, select = "Item1", Augenfarbe == "blau")
```

```R
subset(select = "Item1", mdf, Augenfarbe == "blau")
```

```R
subset(mdf, "Item1", Augenfarbe == "blau")
```

```R
subset("Item1", mdf, Augenfarbe == "blau")
```
