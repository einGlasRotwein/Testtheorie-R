
# `data.frames` {#dataframes}

Wir haben gelernt, dass `R` Daten in Vektoren abspeichert. Im Normalfall
haben wir aber in der psychometrischen Datenauswertung eine große Menge
Daten -- also mehr als einen Wert pro "Fall" --, die wir nicht sinnvoll
als einzelnen Vektor darstellen können. Etwa: 150 Studierende bearbeiten
in einer Diagnostikklausur 42 Multiple-Choice-Klausuritems. Wir stellen
solche Daten in Tabellen dar, wie wir sie auch aus Excel oder SPSS
kennen. Spalten stellen Messvariablen dar, etwa die Punktzahlen in einer
Klausuraufgabe. Zeilen stellen Fälle dar. Ein Fall könnte etwa eine
Testteilnehmerin sein, für die in mehreren Spalten ihre Punktzahlen in
allen Aufgaben abgespeichert sind.[^`r incref()`] In `R` speichert man
solche Datentabellen in `data.frames` ab. Ein `data.frame` ist --
vereinfacht gesagt -- eine Sammlung von Vektoren; jede Spalte, d.h. jede
Messvariable ist ein Vektor.

[^`r incfnc()`]: Andere Formate sind auch denkbar, etwa eines in dem
jede Zeile eine Aufgabe darstellt. Bei uns wird aber im Normalfall
gelten: eine Zeile entspricht einem Fall -- oftmals einer Person.

## Die Funktion `data.frame`

Mit der Funktion `data.frame` kann ich "händisch" einen `data.frame`
erstellen. In der Praxis werden wir das aber wohl nur selten machen und
stattdessen Daten aus einer externen Datei einlesen.[^`r incref()`]

[^`r incfnc()`]: Beispielsweise können die Daten in einem
*Spreadsheet-Editor* wie Excel eingegeben worden sein und wir
importieren diese dann in `R`.

```{r}
meinDataFrame <-  data.frame(Nummer = 1:5,
                             Item1 = c(1, 0, 0, 1, 1),
                             Item2 = c(1, 1, 0, 0, 1),
                             Alter = c(13, 14, 13, 12, 15),
                             Geschlecht = c("w", "m", "m", "w", "m")
                             )
meinDataFrame
```

Bei dieser Erstellung des `data.frames` wird deutlich, dass Spalten
Vektoren enthalten, da wir für jede Spalte einen Vektor mit der Funktion
`c` bzw. mit dem Doppelpunktoperator erstellen. Wir sehen auch, dass die
Spalten bei der Erstellung des `data.frames` benannt werden können.
**Dieser Punkt ist sehr wichtig, da wir Spalten anhand ihres Namens
gezielt auswählen können**. Wenn ich die Spaltennamen, also die Namen
der Messvariablen eines `data.frames` nicht weiß -- etwa weil ich die
Daten aus einer Datei eingelesen habe -- kann ich diese mit dem Befehl
`names` herausfinden:

```{r}
names(meinDataFrame)
```

Diese unscheinbare Tabelle mit nur 5 Einträgen wird uns durch einen
Großteil des Kapitels begleiten, um Grundlagen von
`data.frame`-Operationen zu betrachten.

## Datenzugriffe

Wir lernen in diesem Abschnitt die wichtigsten Möglichkeiten kennen,
aus `data.frames` Daten auszuwählen. Dabei lernen wir Zeilen und Spalten
separat auszulesen.

### Zugriff auf eine einzelne Spalte: die `$`-Notation

Ich kann auf eine einzelne Spalte eines `data.frame` mit der
`$`-Notation zugreifen:

```{r}
punkte <- meinDataFrame$Item1
punkte # `punkte` ist ein Vektor
```

Der `$`-Zugriff ist für uns die grundlegendste Operation auf
`data.frames`. Er liest eine einzelne Spalte eines `data.frames` **als
Vektor** aus.  Ich kann den `$`-Zugriff nicht nur verwenden, um eine
Spalte aus einem `data.frame` auszulesen, sondern kann damit auch neue
Spalten zum `data.frame` hinzufügen, indem ich einer neuen Spalte mit
"`<-`" einen neuen Vektor zuweise:

```{r}
meinDataFrame$Augenfarbe <- c("blau", "grau", "blau", "braun", "grün")
```

```{r}
meinDataFrame
```

Beim Anhängen von Spalten an `data.frames` mit der `$`-Notation kann ich
jegliche Berechnungsvorschriften für Vektoren verwenden. So kann ich
etwa einen Testscore über zwei Items berechnen und direkt an den
`data.frame` anhängen:

```{r}

meinDataFrame$Testscore <- meinDataFrame$Item1 + meinDataFrame$Item2

meinDataFrame$Testscore

```

Beachtet, dass in diesem Fall recht häufig die `$`-Notation zum Einsatz
kommt, was etwas gewöhnungsbedürftig aussieht. Aber es ist wichtig
darauf zu achten. Die Variablen,[^`r incref()`] die wir in diesem
Beispiel verwenden, um den Testscore zu berechnen "wohnen" in
`meinDataFrame` und können nicht ohne Verweis darauf adressiert
werden. Das hier geht schief:

[^`r incfnc()`]: Es ist etwas unglücklich, dass der Begriff "Variable"
eine doppeldeutige Verwendung hat: (1) In `R`
sind Variablen die Speicherorte von Objekten, die ich mit der "`<-`"
Zuweisung erstelle. (2) Andererseits bezeichnet man auch Messwerte, etwa
die Punktzahlen in einem Testitem, als Variable. In `R` würde man sich
bei dieser Verwendung des Begriffs Variable dann auf die Spalte in einem
`data.frame` beziehen. Diese Verwechslung ist unglücklich, da eine
`data.frame` Spalte gar keine `R`-Variable ist. Stattdessen speichern
wir den gesamten `data.frame` in **einer** Variablen ab.

```R
meinDataFrame$Testscore <- Item1 + Item2
Fehler: Objekt 'Item1' nicht gefunden
```

Hier sucht `R` nach einer Variablen `Item1`, die aber nicht existiert;
`Item1` ist nur eine Spalte von `meinDataFrame`. Noch schlimmer wäre es,
wenn in meiner Arbeitsumgebung tatsächlich Variablen mit den Namen
`Item1` und `Item2` existieren. Dann würde ich nicht einmal eine
Fehlermeldung erhalten und hätte gegebenenfalls falsche Daten
abgespeichert.

Mit der `$`-Notation werden wir häufig auf Daten zugreifen, um
Berechnungen anzustellen. Wir können beispielsweise Mittelwerte von
Messvariablen berechnen, oder uns Häufigkeiten von Daten angeben lassen:

```{r}
mean(meinDataFrame$Alter)
table(meinDataFrame$Geschlecht)
```

Die Funktion `mean` kennen wir bereits. Die Funktion `table` berechnet
die Häufigkeiten von Werten, die in Vektoren vorkommen. Sie ist vor
allem nützlich, um kategorielle Messvariablen zu beschreiben. Zur
Überprüfung der Plausibilität von Daten ist `table` extrem
nützlich. (Ist jeder Wert ein "legaler" Wert, der auch vorkommen
sollte?) Ich kann die Funktion `table` auch verwenden, um die Häufigkeit
der Kombination von mehreren Variablen zu erfragen, etwa wie häufig
welcher Testscore nach Geschlecht auftaucht:

```{r}
## Erstelle Kreuztabelle von Geschlecht und Augenfarbe:
table(meinDataFrame$Augenfarbe, meinDataFrame$Geschlecht)
```

### Zugriff auf Spalten und Zeilen: die `[·,·]`-Notation

Einzelne Spalten können wir aus `data.frames` mit dem `$`-Zugriff
auslesen. Wir lernen nun den `[·,·]`-Zugriff kennen, mit dem wir nicht
nur einzelne Spalten, sondern beliebige Spalten und Zeilen auswählen
können.[^`r incref()`]

[^`r incfnc()`]: Während uns der `$`-Zugriff uns immer genau einen
Vektor zurückgibt, werden wir mit dem `[·,·]`-Zugriff zumeist einen
ganzen `data.frame` auslesen.

Wir könnten beispielsweise nur eine Teilmenge aller Fälle aus
`meinDataFrame` auswählen; etwa nur die Personen mit blauen Augen, oder
alle Personen, die den maximalen Testwert erreicht haben. Für solche
Auswahlen hilft uns unser Wissen über logische Vergleiche aus dem
letzten Kapitel. Betrachten wir zunächst ein Beispiel:[^`r incref()`]

[^`r incfnc()`]: Beachtet, dass durch diesen Aufruf die Tabelle
`meinDataFrame` nicht verändert wird. Die Funktion gibt stattdessen eine
neue Tabelle zurück, die nur die Fälle enthält, bei denen
`meinDataFrame$Augenfarbe == "blau"` gilt. Wir müssten das Ergebnis der
Funktion in einer Variablen speichern, wenn wir damit weiter arbeiten
wollen (Erinnerung: [Kapitel 2](#ausgabevsabspeichern)).

```{r}
meinDataFrame[, meinDataFrame$Augenfarbe == "blau"]
```

Auf diese Weise haben wir mit einem logischen Vergleich aus der Tabelle
nur zwei Zeilen ausgewählt, nämlich die der Personen mit blauen Augen.



Allgemein ist die Syntax zum Ansprechen von `data.frames` mit dem `[·,·]`-Operator ist
die Folgende:

```
data.frame[Reihenvektor, Spaltenvektor]
```

Dabei ist *Reihenvektor*/*Spaltenvektor* entweder ein (a) numerischer
Vektor, der die Indexe der Reihen/Spalten enthält, die ausgewählt werden
sollen, oder (b) ein logischer Vektor, der für jede Reihe/Spalte
kodiert, ob diese in der Ausgabe enthalten sein soll (vgl. Kapitel
[2](#logischerZugriff)), oder (c) ein "character" Vektor, der die
Zeilen/Spalten, die ausgegeben werden sollen, nach Namen
auswählt.[^`r incref()`]

[^`r incfnc()`]: Es ist möglich, dass auch Zeilen Namen haben. Häufig
sind Zeilen aber nur nummeriert und nicht explizit benannt.

&nbsp;

Es ist möglich, dass entweder der Spaltenvektor oder der Reihenvektor
leer ist; in dem Fall findet die Auswahl nur nach Reihe bzw. Spalte
statt. Das ist analog dazu, dass wir mit der Funktion `subset` eines der
Argumente `subset` oder `select` auslassen. Das führt zu einer
gewöhnungsbedürftig aussehenden Syntax:

```
data.frame[Reihenvektor, ]
data.frame[, Spaltenvektor]
```

Tatsächlich wird man häufig nur entweder nach Spalte oder nach Zeile
auswählen und nicht unbedingt beides kombinieren. Wie und ob ich an
dieser Stelle vor oder nach dem Komma Leerzeichen setze, hat keine
Bedeutung.

Durch die UND bzw. ODER Operationen können wir auch komplexere
Anforderungen an die Auswahl stellen:

```{r}
subset(meinDataFrame, Augenfarbe == "blau" | Augenfarbe == "grün")

subset(meinDataFrame, (Augenfarbe == "blau" | Augenfarbe == "grün") & Item1 == 1)

```

Hier merken wir, dass diese Notation recht schnell etwas unübersichtlich
wird. Weiter unten lernen wir mit der Funktion `subset` eine Möglichkeit
kennen, solche logischen Anfragen an die Auswahl von Fällen etwas
prägnanter zu gestalten.

Wie schon erwähnt, können wir mit `subset` nicht nur Zeilen, sondern
auch Spalten auswählen:

```{r}
subset(meinDataFrame, Augenfarbe == "blau", c("Item1", "Augenfarbe"))
```

Hierbei habe ich mit dem dritten Argument `c('Item1', 'Augenfarbe')`
eine Auswahl der Spalten durchgeführt. Dazu habe ich einen Vektor vom
Typ `character` übergeben, der die auszulesenden Spalten mit Namen
adressiert. Durch die Kombination der Auswahl von Zeilen und Spalten
wird mir insgesamt ein `data.frame` ausgegeben, der nur die Spalten
"Item1" und "Augenfarbe" enthält, und diese nur für Personen mit blauen
Augen.

Wie erwähnt, ist es auch in `data.frames` möglich, Zugriffe per Index
durchzuführen. Das heißt für uns: Wir können beispielsweise die erste
Spalte auswählen, ohne explizit den Namen der Spalte anzugeben. Das ist
besonders nützlich, wenn wir mit großen Datentabellen arbeiten. Um etwa
Items des NPI zu "bepunkten", müssen wir Antworten aus 40 Spalten
umkodieren. Dabei kann es nützlich sein nacheinander "links nach rechts"
(also von der ersten zur letzten Spalte, d.h. 1, ..., 40) alle Spalten
per Index anzusprechen. Diese Funktionalität bietet uns der
`[·,·]`-Operator. Dieser ist ein sehr mächtiges Werkzeug zur Bearbeitung
von Daten in `R`. Unter anderem bietet er uns die Möglichkeit, die
Funktionalität von `subset` zu reproduzieren.

&nbsp;

Im Folgenden finden weitere Beispiele für die verschiedenen
Auswahlmöglichkeiten per `[·,·]`. Wir verwenden weiterhin die Tabelle
`meinDataFrame`

```{r}
## Wähle per Index die ersten drei Zeilen aus
meinDataFrame[1:3,]

## Wähle per Index die zweite und vierte Spalte aus
meinDataFrame[,c(2, 4)]

## Wähle per logischem Vektor alle Personen aus, die beide Aufgaben
## richtig gelöst haben:
meinDataFrame[meinDataFrame$Testscore == 2,]

## Wähle alle Personen aus, die blaue oder braune Augen haben:
meinDataFrame[meinDataFrame$Augenfarbe == "blau" | meinDataFrame$Augenfarbe == "braun",]

## Wähle Fallnummer, Alter und Testscore per Spaltenname aus:
meinDataFrame[, c("Nummer", "Alter", "Testscore")]

## Wähle Fallnummer, Alter und Testscore aus für alle Personen, die
## älter als 13 sind
meinDataFrame[meinDataFrame$Alter > 13, c("Nummer", "Alter", "Testscore")]

## Wähle Fallnummer, Alter und Testscore aus für die ersten drei Fälle
meinDataFrame[1:3, c("Nummer", "Alter", "Testscore")]

## Wähle die Itemscores aus - nutze dabei die Funktion past0e
meinDataFrame[, paste0("Item", 1:2)]

```

&nbsp;

\fbox{
  \parbox{\textwidth}{

  \textbf{\\ Merke:}

  Mit dem \texttt{[·,·]} Zugriff wird zuerst -- vor dem Komma -- die
  Reihe und dann -- nach dem Komma -- die Spalte adressiert. Man kann
  die Auswahl nach numerischem Index, mit einem logischen Vektor, oder
  mit einem \texttt{character} Vektor durchführen.

  }
}

### Weitere Zugriffsmöglichkeiten auf Spalten

Dieser Abschnitt behandelt noch zwei weitere Varianten des Zugriffs per
eckigen Klammern auf data.frames. Da wir diese Zugriffe erst einmal
nicht weiter verwenden werden, kann dieser Abschnitt problemlos
übersprungen werden; wir konzentrieren uns zunächst auf den `$`-ZUgriff
und den `[·,·]`-Zugriff. Zwar sind Datenzugriffe mit der `[ ]`-Familie
sind etwas, das bei `R`-Anfängern regelmäßig zu Kopfschmerzen führt,
jedoch sind diese Zugriffe sind zentral für `R` als Programmiersprache.
Früher oder später wird man deswegen nicht nicht daran vorbeikommen. Für
uns dieser Abschnitt jedoch erst einmal nur als Zusatzinfo
beziehungsweise Nachschlagsmöglichkeit gedacht.

**Der `[[·]]`-Zugriff**

Äquivalent zum `$`-Zugriff funktioniert der folgende `[[·]]` Zugriff auf
eine einzelne Spalte:

```{r}
punkte2 <- meinDataFrame[["Item1"]]
punkte2
```

Hierbei wird der Spaltenname als Text angesprochen. Das heißt, dass die
Anführungszeichen notwendig sind, wenn man die `[[·]]`-Notation
verwendet. Daraus ergibt sich, dass man statt der expliziten Angabe des
Texts auch eine Variable übergeben kann, die einen ein-elementigen
`character`-Vektor enthält. Das ist mit der der `$`-Notation nicht
möglich.[^`r incref()`]

[^`r incfnc()`]: Als ich zum ersten Mal diese Funktionalität -- dass man
eine Variable zum Zugriff mit der `[[·]]`-Notation verwenden kann --
kennengelernt habe, war ich nicht sonderlich beeindruckt. Warum sollte
das irgendeinen Vorteil gegenüber der `$`-Notation bringen? Tatsächlich
gibt es dafür Anwendungsfälle und wir werden einen wichtigen in Kapitel
6 kennenlernen.

```{r}
auswahl <- "Augenfarbe"
meinDataFrame[[auswahl]]
```

Es wäre auch möglich, eine Funktion in die `[[·]]`-Klammerung zu
übergeben, die uns einen ein-elementigen Vektor vom Typ character
zurückgibt -- etwa die Funktion `paste0`:

```{r}
meinDataFrame[[paste0("Item", 1)]]
```

Dieser Zugriff wird für uns noch einmal interessant werden, da wir so
mithilfe von *Schleifen*[^`r incref()`] (in Kapitel 6) in `data.frames`
nacheinander auf beliebig viele Spalten zugreifen können. Dabei wird es
vor allem interessant sein, nacheinander auf die Antworten auf Testitems
(Item **1**, Item **2**, ...) zuzugreifen.

[^`r incfnc()`]: In einer Schleife können wir dann den numerischen Wert
-- hier `1` -- nacheinander immer wieder austauschen (1, 2, 3, 4, ...)
-- ohne, dass wir den Code immer wieder händisch neu schreiben müssen.

**Der `[·]`-Zugriff**

**Nicht** äquivalent zu den Zugriffen mit `$` und `[[·]]` ist folgender
`[·]` Zugriff. Auch hier sind Anführungszeichen zur Identifikation der
auszuwählenden Spalte nötig:

```{r}
punkte3 <- meinDataFrame["Item1"]
punkte3
```

Der Unterschied von `[·]` zu `[[·]]` und `$`: `[[·]]` und `$` ergeben
einen Vektor, `[·]` einen `data.frame`. Für uns bedeutet das, dass wir
mit dem `[·]`-Zugriff auch gleichzeitig mehrere Spalten auswählen
können, indem wir einen Vektor vom Typ `character` mit mehreren
Elementen angeben. Hier hat die unscheinbare Funktion `c` noch mal einen
Auftritt, sodass wir wie beim `[·,·]`-Zugriff mehrere

```{r}
meinDataFrame[c("Item1", "Augenfarbe")]
```

Dieser Ausdruck ist äquivalent zu

```{r}
subset(meinDataFrame, select = c("Item1", "Augenfarbe"))
```

\fbox{
  \parbox{\textwidth}{

  \textbf{\\ Merke:}

  Man kann mit \texttt{\$}, \texttt{[[·]]} und \texttt{[·]} auf
  Spalten in \texttt{data.frames} zugreifen; dabei ergeben \texttt{\$}
  und \texttt{[[·]]} einen Vektor, \texttt{[·]} einen
  \texttt{data.frame}.

  }
}

&nbsp;

&nbsp;

**Worin unterscheiden sich [·,·] und [·] bei data.frames?**

### Zugriff auf Spalten und Zeilen: die Funktion `subset` {#subset}

Einzelne Spalten aus `data.frames` können wir mit dem `$`-Zugriff
auslesen. Wir lernen nun die Funktion `subset`[^`r incref()`] kennen,
mit der wir bequem beliebige Spalten und Zeilen aus `data.frames`
auswählen können. Anders als bei der Auswahl mit dem `$`-Operator --
dessen Rückgabe ein Vektor ist --, gibt uns die Funktion `subset` immer
einen ganzen `data.frame` zurück.

[^`r incfnc()`]: Der Abschnitt zur Funktion `subset` ist ein besonders
wichtiger Abschnitt, da hier nicht nur die spezielle Funktionalität
einer einzelnen Funktion erläutert wird, sondern auch an ihrem Beispiel
allgemeine Eigenschaften von Funktionen in `R` dargestellt werden.

Mit `subset` können wir beispielsweise nur eine Teilmenge aller Fälle
auswählen; etwa nur die Personen mit blauen Augen. Für diese Auswahl
hilft uns unser Wissen über logische Vergleiche aus dem letzten
Kapitel:[^`r incref()`]

[^`r incfnc()`]: Beachtet, dass durch diesen Aufruf die Tabelle
`meinDataFrame` nicht verändert wird. Die Funktion gibt stattdessen eine
neue Tabelle zurück, die nur die Fälle enthält, bei denen
`Augenfarbe == "blau"` gilt. Wir müssten das Ergebnis der Funktion in
einer Variablen speichern, wenn wir damit weiter arbeiten wollen
(Erinnerung: [Kapitel 2](#ausgabevsabspeichern)).

```{r}
subset(meinDataFrame, Augenfarbe == "blau")
```

Auf diese Weise haben wir mit einem logischen Vergleich aus der Tabelle
nur zwei Zeilen ausgewählt. Ihr merkt: In der Funktion `subset` kann ich
für die logische Auswahl nach Augenfarbe die Spalte `Augenfarbe` direkt
mit ihrem Namen adressieren, ohne dass ich die `$`-Notation
verwende. Das ist eine Besonderheit der Funktion `subset`; außerhalb der
Funktion würde der Befehl `Augenfarbe == "blau"` einen Fehler ausgeben,
da `Augenfarbe` selbst keine Variable ist -- nur eine Spalte von
`meinDataFrame`.[^`r incref()`] Innerhalb der Funktion `subset`
funktioniert es nur deswegen, da das erste Argument der `data.frame`
ist, aus dem ich Daten auswähle. Die Funktion `subset` weiß somit, auf
welchen Daten sie operieren muss. Das Folgende ist also nicht nötig,
obwohl es auch funktionieren würde:

[^`r incfnc()`]: Es macht an dieser Stelle Sinn, einen Moment inne zu
halten und zu überlegen, warum es eigentlich außergewöhnlich ist, dass
der Befehl `Augenfarbe == "blau"` innerhalb der Funktion `subset`
funktioniert.

```R
subset(meinDataFrame, meinDataFrame$Augenfarbe == "blau")
```

Dementsprechend könnte man auch der Funktion `subset` -- dieses
Verhalten kennen wir von der `[·]`-Notation zur Auswahl von Elementen
aus Vektoren -- einen beliebigen logischen Vektor zur Auswahl der Zeilen
übergeben:

```{r}
subset(meinDataFrame, c(TRUE, FALSE, FALSE, TRUE, FALSE)) # wählt die erste und vierte Zeile aus
```

Durch die UND bzw. ODER Operationen können wir auch komplexere
Anforderungen an die Auswahl stellen:

```{r}
subset(meinDataFrame, Augenfarbe == "blau" | Augenfarbe == "grün")

subset(meinDataFrame, (Augenfarbe == "blau" | Augenfarbe == "grün") & Item1 == 1)

```

Wie schon erwähnt, können wir mit `subset` nicht nur Zeilen, sondern
auch Spalten auswählen:

```{r}
subset(meinDataFrame, Augenfarbe == "blau", c("Item1", "Augenfarbe"))
```

Hierbei habe ich mit dem dritten Argument `c('Item1', 'Augenfarbe')`
eine Auswahl der Spalten durchgeführt. Dazu habe ich einen Vektor vom
Typ `character` übergeben, der die auszulesenden Spalten mit Namen
adressiert. Durch die Kombination der Auswahl von Zeilen und Spalten
wird mir insgesamt ein `data.frame` ausgegeben, der nur die Spalten
"Item1" und "Augenfarbe" enthält, und diese nur für Personen mit blauen
Augen.[^`r incref()`]

[^`r incfnc()`]: **Merke**: `subset` gibt immer einen `data.frame`
zurück -- selbst dann, wenn ich nur eine einzige Spalte anfordere. Mit
dem `$`-Operator könnte ich hingegen eine einzelne Spalte als Vektor
auslesen.

Bei dieser Verwendung der Funktion `subset` fällt eine allgemeine
Eigenschaft von Funktionen auf: `subset` erkennt anhand der Reihenfolge
der Argumente, wie sie sich zu verhalten hat. Das erste Argument
übergibt den `data.frame`, von dem wir Daten anfordern. Das zweite
Argument wählt mit einem logischen Ausdruck **Zeilen** aus, das dritte
Argument wählt durch einem `character`-Vektor **Spalten** aus. Was
passiert, wenn wir diese Reihenfolge ändern?

```R
subset(meinDataFrame, c("Item1", "Augenfarbe"),
       Augenfarbe == "blau")

Fehler in subset.data.frame(meinDataFrame,
c("Item1", "Augenfarbe"), Augenfarbe ==  : 'subset' muss
boolesch sein
```

Hier erhalten wir eine schwierig zu verstehende Fehlermeldung. Aber uns
ist der Fehler klar: das zweite Argument von `subset` muss die Auswahl
der Zeilen beschreiben, wir haben aber stattdessen einen
`character`-Vektor übergeben, der die Spalten auswählen sollte. Was
können wir machen, wenn wir **nur** eine Auswahl nach Spalte ausführen
wollen? Wir können das zweite Argument ja nicht leer lassen, denn das
führt zum obigen Fehler.

Dieses Problem lässt sich mit einer praktischen Eigenschaft der
`R`-Sprache lösen: **In `R` haben die Argumente von Funktionen Namen.**
Bislang haben wir das ignoriert bzw. nur am Rande mitbekommen (erinnern
wir uns an das Argument `na.rm` der Funktion `mean`).

Die Funktion `subset` hat die folgenden drei benannten Argumente:

- `x`: der Datensatz, aus dem ausgewählt wird
- `subset`: die Auswahl der Zeilen
- `select`: die Auswahl der Spalten

Um eine Übersicht über die verschiedenen Argumente einer Funktion zu
erhalten, können wir die eingebaute Hilfe von `R` verwenden, die wir mit
dem `?`-Operator erhalten. Wir verwenden sie wie folgt:

```R
?subset
```

Die `R`-Hilfe informiert uns unter anderem über die Argumente, die
Funktionen annehmen können. Leider ist diese Hilfe oftmals kryptisch --
und das nicht nur für Anfänger. Sie ist die offizielle Dokumentation von
Funktionen und legt deswegen zwar großen Wert auf technische
Genauigkeit, ist aber nicht immer sonderlich ausführlich oder gar
verständlich. Wir werden in Kapitel 5 bei einer ausführlicheren
Besprechung von Funktionen noch einmal darauf zurückkommen, wie wir mit
der Hilfe-Funktion umgehen können.

Wenn wir die verschiedenen Argumente der Funktion `subset` kennen,
können wir sie auch mit der folgenden Notation ausführen:

```{r}
subset(x = meinDataFrame, subset = Augenfarbe == "blau",
       select = c("Item1", "Augenfarbe"))
```

Hierbei benennen wir die Argumente, die wir nutzen, explizit.  Wie wir
es schon beim Argument `na.rm` der Funktion `mean` kennengelernt haben,
können wir Argumente mit der Schreibweise "`Funktionsargument = Wert`"
adressieren. "`Wert`" ist dabei immer ein `R`-Objekt,
"`Funktionsargument`" der Name des Arguments. Im Fall von `subset`
nehmen die drei Argumente folgende Objekte an:[^`r incref()`]

[^`r incfnc()`]: Die Funktion `subset` lässt hier ein paar Ausnahmen zu,
die weiter unten besprochen werden. Die erste Ausnahme kennen wir schon:
Das Argument `subset` akzeptiert auch, wenn wir einen Ausdruck
übergeben, der außerhalb der Funktion gar nicht als logischer Vektor
erkannt würde.

1. `x`: einen `data.frame`
2. `subset`: einen logischer Vektor
3. `select`: einen Vektor vom Typ `character`

Wenn ich Funktionsargumente mit Namen adressiere, kann ich die
Reihenfolge, in der ich sie der Funktion übergebe, beliebig
vertauschen. Dieser Aufruf etwa ist äquivalent (d.h. führt zur selben
Ausgabe) wie der obige Aufruf:


```R
subset(select = c("Item1", "Augenfarbe"),
       subset = Augenfarbe == "blau", x = meinDataFrame)
```


```{r, echo = FALSE}
## doppelter Code wegen Formatierung =/
subset(select = c("Item1", "Augenfarbe"),
       subset = Augenfarbe == "blau", x = meinDataFrame)
```

In `R` kann man **fast immer**[^`r incref()`] Argumente per Position und
per Name ansprechen. Oftmals wollen wir die Namen von Funktionen
explizit verwenden, da viele Funktionen *optionale* Argumente haben --
also solche, die wir nicht immer angeben müssen. Wir können ja
beispielsweise das Argument `select` weglassen, wenn wir nach Zeilen,
aber nicht nach Spalten selegieren wollen. Analog muss ich nicht das
Argument `subset` angeben -- in dem Fall werden alle Zeilen ausgegeben,
aber nur eine Teilmenge der Spalten, wie in diesem Beispiel:

[^`r incfnc()`]: Eine Ausnahme bildet hier die Funktion `c`, bei der wir
keine Funktionsnamen angeben. Hier gilt nämlich: wir können beliebig
viele Vektoren als Argumente angeben und deswegen gibt es natürlich
keinen separaten Namen für jedes mögliche Argument. Feste Namen gibt es
aber normalerweise, wenn es eine feste Anzahl an möglichen Argumenten
gibt -- wie bei der Funktion `subset`.

```{r}
subset(meinDataFrame, select = c("Testscore", "Geschlecht"))
```

Mit diesem Aufruf werden mir alle 5 Fälle zurückgegeben, aber für diese
nur der Testscore und das Geschlecht. Wie dieser Aufruf zeigt, kann ich
Auswahl nach Position und Auswahl nach Namen mischen. Für das erste
Argument -- `meinDataFrame` -- habe ich den Argumentnamen `x` nicht
angegeben. Daher wurde das Argument anhand der Position
identifiziert. Das hat funktioniert, da das erste Argument der
`data.frame` ist, aus dem die Datenauswahl stattfindet. Für die Auswahl
der Spalten habe ich jedoch den Argumentnamen angegeben. **Das war auch
nötig**, da `subset` als zweites Argument sonst die Auswahl der Zeilen
erwartet hätte.

&nbsp;

\fbox{
  \parbox{\textwidth}{

  \textbf{\\ Merke}

   In \texttt{R} können Funktionsargumente per Position und per Namen
   identifiziert werden. Die Identifikation per Name schlägt dabei die
   Identifikation per Position.

  }
}

 &nbsp;

 &nbsp;

**Ausnahmeregeln für die Funktion `subset`**

Inhalt folgt.

### Zugriff nach Name und Index {#nameindex}

Nachdem die Möglichkeiten zum Zugriff auf `data.frames` besprochen sind,
stellen wir zum Abschluss ein grundsätzliches Prinzip zu Datenzugriffen
in `R` fest: Man kann Zugriffe -- seien es Vektoren, `data.frames` oder
auch andere Strukturen, die wir noch gar nicht behandelt haben -- **nach
Index oder nach Name** durchführen. Wir haben bereits Beispiele für
beides kennengelernt: In Vektoren haben wir Zugriffe mithilfe von
Indexen durchgeführt, indem wir (a) die Position von auszuwählenden
Elementen explizit mit einem numerischen Vektor angegeben haben, oder
(b) indem wir einen logischen Vektor übergeben haben, der anhand von
`TRUE` und `FALSE` Werten die Indexe auswählt, deren Elemente ausgegeben
werden sollen. Der Vollständigkeit halber sei hier mitgeteilt, dass man
sogar bei Vektoren Zugriffe nach Namen durchführen kann, wenn die
Elemente des Vektors benannt sind. Das ist gar nicht so ungewöhnlich;
wie folgt könnte man einen Vektor mit benannten Elementen erstellen und
mit der bekannten `[·]`-Notation darauf zugreifen.  

```{r}

## Benannte Vektoren erstellen funktioniert wie einen data.frame zu
## erstellen:
vec <- c(foo = 1, bar = 2)
vec

vec["foo"]
vec["bar"]
vec[c("bar", "foo")]

```

In `data.frames` haben wir Spalten zumeist nach Namen ausgewählt:
- Mit der `$`-Notation
- Mit der `[·,·]`-Notation
- Mit der Funktion `subset`
- Mit der `[[·]]`-Notation
- Mit der `[·]`-Notation

 Mit der `[·,·]`-Notation können wir in `data.frames` zusätzlich auch
 Zugriffe nach numerischem oder logischen Index durchführen, wie wir
 gesehen haben. Dabei kann die Auswahl sowohl nach Spalten als auch nach
 Zeilen -- oder beidem -- geschehen.

## Nützliche Funktionen zum Arbeiten mit `data.frames` {#convenient}


### `tapply` {#tapply}

Die Funktion `tapply` kann ich verwenden, um mir deskriptive
Statistiken anhand von Gruppierungsvariablen ausgeben zu lassen, hier
etwa die mittlere Punktzahl oder das mittlere Alter nach Geschlecht der
Schüler/innen:

```{r}
tapply(meinDataFrame$Testscore, meinDataFrame$Geschlecht, mean)
tapply(meinDataFrame$Alter, meinDataFrame$Geschlecht, mean)
```

Die Funktion `tapply` erhält als erstes Argument den Messwertvektor, für
den Statistiken angefordert werden. Das zweite Argument ist die
Gruppierungsvariable.[^`r incref()`] Interessanterweise ist das dritte
Argument eine Funktion, in diesem Fall die Funktion `mean`. So können
wir die *mittlere* Punktzahl nach Geschlecht anfordern. Entsprechend
könnten wir hier andere Funktionen übergeben, um etwa die
Standardabweichung des Alters zu erfragen:

[^`r incfnc()`]: Beachtet, dass sowohl Messwerte als auch
Gruppierungsvariable als **Vektoren** übergeben werden. Ich behandle die
Funktion `tapply` jedoch im Kapitel zu `data.frames`, da es zumeist so
sein wird, dass wir beide Vektoren aus **einem** `data.frame` mit der
`$`-Notation auslesen werden.

```{r}
tapply(meinDataFrame$Alter, meinDataFrame$Geschlecht, sd)
```

Wie `table` kann auch `tapply` deskriptive Statistiken anhand mehrerer
Gruppierungsvariablen anfordern. Um mehrere Gruppierungsvariablen
anzufordern, klammern wir `list(...)` um die Gruppierungsvektoren im
zweiten Argument:

```{r}
tapply(meinDataFrame$Alter, list(meinDataFrame$Geschlecht,
                                 meinDataFrame$Augenfarbe), mean)
```

Mit nur fünf Datenpunkten macht diese Anfrage hier nur wenig Sinn, da
jeder ausgegebene Mittelwert nur anhand eines einzelnen Wertes gebildet
wurde,[^`r incref()`] was die Idee des Mittelwerts eher ad absurdum
führt. Manche Kombinationen von Geschlecht und Augenfarbe kommen in
unseren Daten sogar gar nicht vor; in diesen Fällen wird `NA`
ausgegeben. `tapply` zeigt ihre Stärke vor allem, wenn man viele -- und
nicht nur 5 -- Datenpunkte hat. Das gilt gerade dann, wenn wir mehrere
Gruppierungsvariablen angeben.

[^`r incfnc()`]: Wie viele Datenpunkte in die Berechnung jedes
Mittelwerts eingehen, können wir in diesem Fall prüfen mit
`table(meinDataFrame$Geschlecht, meinDataFrame$Augenfarbe)`.

### `nrow` und `ncol`

Die Zahl der Zeilen eines `data.frame`s -- d.h. oftmals die Zahl der
*Fälle* -- lässt sich mit der Funktion `nrow` bestimmen, die man sehr
häufig verwendet:

```{r}
nrow(meinDataFrame)
```

Analog ergibt `ncol` die Zahl der Spalten:

```{r}
ncol(meinDataFrame)
```

### `head` und `tail`

Um sich einen Überblick über einen `data.frame` zu verschaffen, sind die
Funktionen `head` und `tail` sehr nützlich. `head` gibt die ersten
Zeilen eines `data.frames` zurück, `tail` entsprechend die letzten
Zeilen. Beide Funktionen haben ein zweites Argument *n*, welches wir
nutzen können, um zu steuern, wie viele Zeilen ausgegeben werden
sollen. Wenn wir *n* nicht angeben, werden 6 Zeilen ausgegeben (in
`R`-Jargon: 6 ist der "default"-, also Standardwert des *optionalen
Arguments* n). Beispiel:

```{r}
head(meinDataFrame, n = 2)
tail(meinDataFrame)
```

Im letzteren Fall werden einfach alle Zeilen zurückgegeben, da unser
`data.frame` insgesamt nur fünf Zeilen hat -- und somit weniger als 6.

### Sortieren: `dplyr::arrange`

Oftmals wollen wir Datentabellen nach einer oder mehreren Variablen
sortieren. Dies funktioniert am bequemsten, wenn wir das *Paket* `dplyr`
laden [@R-dplyr]:

```{r}
library("dplyr")
```

Voraussetzung dafür, dass ich das Paket `dplyr` nutzen kann ist, dass
ich das Paket auf meinem Rechner installiert habe. Falls das Paket noch
nicht installiert ist (in dem Fall ergibt der Befehl `library('dyplr')`
einen Fehler) , könnte ich es mit dem folgenden Befehl installieren:

```R
install.packages("dplyr")
```

Pakete stellen zusätzliche Funktionen zur Verfügung, die in der
Basisversion von `R` nicht enthalten sind. Um ein Paket zu nutzen,
müssen wir es mit der Funktion `library` in unsere `R`-Umgebung laden.
Andernfalls könnten wir die Funktionen nicht nutzen, die etwa `dplyr`
enthält. Die Funktion `arrange` aus `dplyr` ermöglicht es uns, einen
`data.frame` zu sortieren:

```{r}
arrange(meinDataFrame, Testscore) # dplyr muss geladen sein
```

In der Funktion `arrange` geben wir als erstes Argument den zu
sortierenden `data.frame` an. Darauf folgen -- mit Komma separiert --
alle Spalten nach denen wir sortieren wollen (hier erst mal nur der
Testscore). Standardmäßig sortiert `arrange` *aufsteigend*, wenn wir
eine absteigende Sortierung wünschen, müssen wir ein Minus vor die
Sortierspalte setzen:

```{r}
arrange(meinDataFrame, -Testscore)
```

Es ist auch möglich, nach mehreren Spalten zu sortieren. In dem Fall
wird bei gleichen Werten im ersten Sortierkriterium anhand des nächsten
Kriteriums die Reihenfolge entschieden. Wir könnten etwa unsere Daten
nach Geschlecht sortieren, und innerhalb der Personen gleichen
Geschlechts nach Punktzahl:

```{r}
arrange(meinDataFrame, Geschlecht, -Testscore)
```

## Zusammenfassung

- Wir haben den `data.frame` als Datenstruktur zur Speicherung von
  psychometrischen Daten kennengelernt
- Wir haben den Zugriff auf Spalten und Zeilen in `data.frames` mit der
  `$`-Notation und der Funktion `subset` kennengelernt
- Zur Anforderung von deskriptiven Statistiken können wir die Funktionen
  `table` und `tapply` verwenden
- Wir haben weitere Funktionen kennengelernt, die uns einen Überblick
  über `data.frames` verschaffen:
    + `names`
    + `nrow/ncol`
    + `head/tail`
    + `dplyr::arrange`

&nbsp;
&nbsp;

## Abschließender Hinweis

\fbox{
  \parbox{\textwidth}{

  \texttt{vector} und \texttt{data.frame} sind die einzigen
  Datenstrukturen, mit denen wir zunächst arbeiten werden. Früher oder
  später wird man sich mit jedoch mit weiteren Datenstrukturen aus
  \texttt{R} auseinandersetzen müssen. Einige wichtige seien deswegen
  schon einmal an dieser Stelle genannt:

  \begin{itemize} \tightlist \item \texttt{matrix}: von der Struktur her
  wie ein \texttt{data.frame}, aber alle Werte müssen denselben Datentyp
  haben

  \item \texttt{list}: ein „Container“, der beliebige andere Daten
  enthalten kann; Zugriffe funktionieren zumeist wie in einem
  \texttt{data.frame}, da \texttt{data.frames} technisch gesehen auch
  Listen sind

  \item \texttt{array}: eine mehrdimensionale Matrix; etwa kann
  \texttt{tapply} einen Array zurückgegeben \end{itemize}

  Häufig kann man die \textit{Klasse}, also die Art der Datenstruktur
  eines Objekts, mit der Funktion \texttt{class} herausfinden (probiert
  den Befehl \texttt{class(data.frame(foo = 1:3))})

  }
}

&nbsp;

## Fragen zum vertiefenden Verständnis

1. Worin unterscheiden sich die folgenden Aufrufe? Welche Aufrufe sind
   zueinander äquivalent?

```R
subset(meinDataFrame, select = "Item1")
```

```R
meinDataFrame[, "Item1"]
```

```R
meinDataFrame[, "Item1", drop = FALSE]
```

```R
meinDataFrame[["Item1"]]
```

```R
meinDataFrame$Item1
```

2. Vergleicht die folgenden Aufrufe der Funktion `subset`. Warum
   funktionieren der erste und der zweite Aufruf, aber nicht der dritte
   und vierte?  Wie kann es überhaupt sein, dass die ersten beiden
   Funktionsaufrufe funktionieren, obwohl Argumente unbenannt an der
   "falschen" Position stehen?

```R
subset(meinDataFrame, select = "Item1", Augenfarbe == "blau")
```

```R
subset(select = "Item1", meinDataFrame, Augenfarbe == "blau")
```

```R
subset(meinDataFrame, "Item1", Augenfarbe == "blau")
```

```R
subset("Item1", meinDataFrame, Augenfarbe == "blau")
```
