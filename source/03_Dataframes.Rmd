
# `data.frames` {#dataframes}

Wir haben gelernt, dass `R` Daten in Vektoren abspeichert. Im Normalfall
haben wir in der psychometrischen Datenauswertung aber eine große
Datenmenge vorliegen, die wir nicht sinnvoll als einzelnen Vektor
darstellen können. Etwa: 150 Studierende bearbeiten in einer
Diagnostikklausur 42 Multiple-Choice-Klausuritems. Wir stellen solche
Daten in Tabellen dar, wie man sie auch aus Excel oder SPSS kennt. In
diesen Tabellen repräsentieren Spalten Messvariablen, etwa die
Punktzahlen in einer Klausuraufgabe. Zeilen stellen Fälle dar, etwa
Personen, die an der Klausur teilgenommen haben. Andere Datenformate
wären auch denkbar, etwa eines bei dem jede Zeile einer Aufgabe
entspricht -- und nicht einer Person. Bei uns wird aber gelten: Jede
Zeile entspricht genau einer Person.

In `R` speichern wir Datentabellen in `data.frames` ab. Ein `data.frame`
ist, vereinfacht gesagt, eine Sammlung von Vektoren gleicher Länge.
Jede Spalte -- also jede Messvariable -- ist ein Vektor. Mit dieser
Datenstruktur werden wir uns im vorliegenden Kapitel auseinandersetzen.

## Die Funktion `data.frame`

Mit der Funktion `data.frame` können wir "händisch" einen `data.frame`
erstellen. In der Praxis werden wir das eher selten machen und
stattdessen Daten aus einer externen Datei einlesen.[^`r incref()`] Die
folgende unscheinbare Tabelle mit 5 Einträgen erstelle ich mit der
Funktion `data.frame`; sie wird uns durch einen Großteil des Kapitels
begleiten, um Grundlagen von `data.frame`-Operationen zu betrachten.

[^`r incfnc()`]: Beispielsweise können die Daten in einem
*Spreadsheet-Editor* wie Excel eingegeben worden sein und wir
importieren diese dann in `R`.

```{r}
 mdf <- data.frame(Nummer = 1:5,
                   Item1 = c(1, 0, 0, 1, 1),
                   Item2 = c(1, 1, 0, 0, 1),
                   Alter = c(13, 14, 13, 12, 15),
                   Geschlecht = c("w", "m", "m", "w", "m")
                   )
mdf
```

Der `data.frame` wird in in einer Variablen mit dem Namen `mdf` -- was
beispielsweise für "mein `data.frame`" stehen könnte -- abgespeichert. Bei der
Erstellung des `data.frames` wurde jede Spalte mit der Funktion `c` oder dem
Doppelpunktoperator mit genau einem Vektor befüllt. Die Spalten des
`data.frames` wurden bei der Erstellung benannt. **Dieser Punkt ist sehr
wichtig, da wir Spalten anhand ihrer Namen gezielt auswählen können**. Wenn ich
die Spaltennamen eines `data.frames` nicht mehr weiß, kann ich sie mit der
Funktion `names` abrufen:

```{r}
names(mdf)
```

## Zugriff auf eine einzelne Spalte: die `$`-Notation

Der `$`-Zugriff ist für uns die grundlegendste Operation auf
`data.frames`. Mit der `$`-Notation können wir auf eine einzelne Spalte
eines `data.frames` zugreifen und diese **als Vektor** auslesen:

```{r}
punkte <- mdf$Item1
punkte # `punkte` ist ein Vektor
```

Ich kann den `$`-Zugriff nicht nur verwenden, um eine Spalte aus einem
`data.frame` auszulesen, sondern kann damit auch neue Spalten zum
`data.frame` hinzufügen. Das geht, indem ich der neu zu erstellenden
Spalte per "`<-`" einen Vektor zuweise:

```{r}
mdf$Augenfarbe <- c("blau", "grau", "blau", "braun", "grün")
```

```{r}
mdf
```

Beim Anhängen von Spalten an `data.frames` mit der `$`-Notation kann ich
jegliche Berechnungsvorschriften für Vektoren verwenden. So kann ich
etwa einen Testscore über zwei Items berechnen und direkt an den
`data.frame` anhängen:

```{r}

mdf$Testscore <- mdf$Item1 + mdf$Item2

mdf$Testscore

```

Beachtet, dass in diesem Fall recht häufig die `$`-Notation zum Einsatz
kommt, was etwas gewöhnungsbedürftig aussieht. Aber es ist wichtig
darauf zu achten. Die Variablen,[^`r incref()`] die wir in diesem
Beispiel verwenden, um den Testscore zu berechnen "wohnen" in
`mdf` und können nicht ohne Verweis darauf adressiert
werden. Das hier geht schief:

[^`r incfnc()`]: Es ist etwas unglücklich, dass der Begriff "Variable"
doppeldeutig ist: (1) In `R` sind Variablen die Speicherorte von
Objekten; ich erstelle sie mit der "`<-`"-Zuweisung.  (2) Andererseits
werden auch Messwerte -- etwa die Punktzahlen in einem Testitem -- als
Variablen bezeichnet. In diesem Sinne würde der Begriff Variable in `R`
auf die Spalte in einem `data.frame` verweisen, da Spalten Messvariablen
beinhalten. Diese Doppeldeutigkeit ist deswegen unglücklich, da eine
Spalte in einem `data.frame` keine `R`-Variable ist. Stattdessen ist der
gesamte `data.frame` in **einer** Variablen abgespeichert.

```R
mdf$Testscore <- Item1 + Item2
Fehler: Objekt 'Item1' nicht gefunden
```

Hier sucht `R` nach einer Variablen `Item1`, die aber nicht existiert;
`Item1` ist nur eine Spalte von `mdf`. Noch schlimmer wäre es, wenn in
meiner Arbeitsumgebung tatsächlich Variablen mit den Namen `Item1` und
`Item2` existieren sollten. In dem Fall würden wir falsche Daten
abspeichern und nicht einmal einmal eine Fehlermeldung
erhalten[^fehler].

[^fehler]: Fehlermeldungen sind grundsätzlich etwas Gutes.

Mit der `$`-Notation werden wir häufig auf Daten zugreifen, um
Berechnungen durchzuführen. Wir können beispielsweise Mittelwerte von
Messvariablen berechnen oder uns Häufigkeiten von Daten angeben lassen:

```{r}
mean(mdf$Alter)
table(mdf$Geschlecht)
```

Die Funktion `mean` kennen wir bereits. Die Funktion `table` berechnet
die Häufigkeiten aller Werte, die in einem Vektor vorkommen. Sie ist vor
allem zur Beschreibung kategorialer Messvariablen nützlich. Auch zur
Überprüfung der Plausibilität von Daten ist `table` extrem
nützlich. (Ist jeder Wert ein "legaler" Wert, der auch vorkommen
sollte?) Ich kann die Funktion `table` auch verwenden, um die Häufigkeit
der Kombination von mehreren Variablen zu erfragen, etwa wie häufig
welcher Testscore nach Geschlecht auftaucht:

```{r}
## Erstelle Kreuztabelle von Geschlecht und Augenfarbe:
table(mdf$Augenfarbe, mdf$Geschlecht)
```

## Zugriff auf Spalten und Zeilen: die `[·,·]`-Notation

Einzelne Spalten können wir mit dem `$`-Zugriff aus `data.frames`
auslesen. Wir lernen nun den `[·,·]`-Zugriff kennen, mit dem wir nicht
nur einzelne Spalten, sondern beliebige Spalten und Zeilen auswählen
können. Wie wir sehen werden, funktioniert der `[·,·]`-Zugriff ähnlich
wie der `[·]`-Zugriff, den wir zur Auswahl von Daten aus Vektoren
kennengelernt haben.

Mit dem `[·,·]`-Zugriff könnten wir beispielsweise nur eine Teilmenge
aller Fälle aus `mdf` auswählen, etwa nur die Personen mit blauen Augen,
oder alle Personen, die den maximalen Testwert erreicht haben. Für
solche Auswahlen hilft uns unser Wissen über logische Vergleiche aus dem
letzten Kapitel. Betrachten wir zunächst ein Beispiel:[^`r incref()`]

[^`r incfnc()`]: Beachtet, dass durch diesen Aufruf der `data.frame`,
der in der Variablen `mdf` abgespeichert ist, nicht verändert wird. Der
`[·,·]`-Zugriff gibt stattdessen einen neuen `data.frame` zurück, der
nur die Fälle enthält, bei denen `mdf$Augenfarbe == "blau"` `TRUE`
ergibt. Wir müssten das Ergebnis der Funktion in einer Variablen
speichern, wenn wir damit weiter arbeiten wollen (Erinnerung: [Kapitel
2](#ausgabevsabspeichern)).

```{r}
mdf[mdf$Augenfarbe == "blau", ]
```

Wie das folgende Beispiel zeigt, können wir mit der `[·,·]`-Notation
auch gezielt Spalten aus `data.frames` auswählen:

```{r}
mdf[, c("Augenfarbe", "Alter")]
```

Die zwei Beispiele zeigen, dass das Komma in der `[·,·]`-Notation
bewirkt, ob eine Auswahl nach Zeilen oder Spalten stattfindet; wie wir
sehen werden, ist auch eine gleichzeitige Auswahl nach Zeilen **und**
Spalten möglich. **Vor dem Komma werden Zeilen adressiert, nach dem
Komma Spalten.** Allgemein ist die Syntax zum Ansprechen von
`data.frames` mit dem `[·,·]`-Zugriff die folgende:

```
data.frame[Reihenvektor, Spaltenvektor]
```

Dabei ist *Reihenvektor*/*Spaltenvektor* entweder ein (a) numerischer
Vektor, der die Indexe der Reihen/Spalten enthält, die ausgewählt werden
sollen, (b) ein logischer Vektor, der für jede Reihe/Spalte kodiert, ob
diese in der Ausgabe enthalten sein soll (vgl. Kapitel
[2](#logischerZugriff)), oder (c) Vektor vom Typ `character`, der die
Namen der Zeilen/Spalten enthält, die ausgegeben werden sollen.
[^`r incref()`]

[^`r incfnc()`]: Auch Zeilen können benannt sein. Den Fall hatten wir
bislang aber nicht und es kommt auch nicht oft vor, dass Zeilen explizit
benannt sind. Häufiger ist der Fall, in dem wir Spalten nach Namen
auswählen.

Es ist möglich, dass in einem einzelnen `[·,·]`-Zugriff sowohl nach
Spalten als auch Zeilen ausgewählt wird. Oftmals wird aber entweder der
Spaltenvektor oder der Reihenvektor "leer" sein. Dann findet die Auswahl
nur entweder nach Zeilen beziehungsweise Spalten statt, wie es auch in
den obigen Beispielen der Fall war.

Häufig werden wir zur Auswahl der gewünschten Spalten einen Vektor vom
Typ `character` angeben -- also die Spaltennamen. Zur Auswahl von Zeilen
wird man häufig einen logischen Vektor verwenden, der die Eigenschaften
der Fälle kodiert, die die auszuwählenden Fälle haben sollen. Aber: Alle
Möglichkeiten sind denkbar, etwa auch, dass ein logischer Vektor zur
Auswahl der Spalten verwendet wird oder wir die Zeilennummern angeben,
die ausgewählt werden sollen.

Durch die UND- bzw. ODER-Operationen können wir auch komplexere
logische Bedingungen zur Auswahl von Fällen formulieren:

```{r}
mdf[mdf$Augenfarbe == "blau" | mdf$Augenfarbe == "grün", ]
mdf[mdf$Augenfarbe == "blau" | mdf$Augenfarbe == "grün" & mdf$Item1 == 1, ]
```

Die `[·,·]`-Notation wird recht schnell unübersichtlich, wenn sie
komplexere logische Anfragen enthält. Hier bewirken das Zusammenspiel
aus den `$`-Zugriffen, den UND- und ODER-Operationen, sowie der Syntax
der `[·,·]`-Notation, dass sich der Code etwas aufbauscht. Die
Verknüpfung mehrerer ODER-Bedingungen ließe sich durch den
`%in%`-Operator verkürzen: 

```{r}
mdf[mdf$Augenfarbe %in% c("blau", "grün"), ]
```

Später lernen wir mit der Funktion `subset` eine Möglichkeit kennen,
komplexere logische Anfragen noch etwas prägnanter zu formulieren.

Zum Abschluss dieses Abschnitts betrachten wir noch einige weitere
Beispiele für die verschiedenen Auswahlmöglichkeiten per `[·,·]`:

```{r}
## Wähle per Index die ersten drei Zeilen aus
mdf[1:3, ]

## Wähle per Index die zweite und vierte Spalte aus
mdf[, c(2, 4)]

## Wähle per logischem Vektor alle Personen aus, die beide Aufgaben
## richtig gelöst haben:
mdf[mdf$Testscore == 2, ]

## Wähle alle Personen aus, die blaue oder braune Augen haben:
mdf[mdf$Augenfarbe == "blau" | mdf$Augenfarbe == "braun", ]

## Wähle Fallnummer, Alter und Testscore per Spaltenname aus:
mdf[, c("Nummer", "Alter", "Testscore")]

## Wähle Fallnummer, Alter und Testscore aus für alle Personen, die
## älter als 13 sind
mdf[mdf$Alter > 13, c("Nummer", "Alter", "Testscore")]

## Wähle Fallnummer, Alter und Testscore aus für die ersten drei Fälle
mdf[1:3, c("Nummer", "Alter", "Testscore")]

## Wähle die Itemscores aus - nutze dabei die Funktion paste0
mdf[, paste0("Item", 1:2)]

```

```{block, type = "block"}
**Merke**: Mit dem `[·,·]` Zugriff wird zuerst -- vor dem Komma -- die
Reihe und dann -- nach dem Komma -- die Spalte adressiert. Man kann die
Auswahl nach numerischem Index, mit einem logischen Vektor, oder mit
einem `character` Vektor durchführen.
```

## Weitere Zugriffsmöglichkeiten auf Spalten {#doppelteckig}

Dieser Abschnitt behandelt zwei weitere Zugriffsmöglichkeiten auf
`data.frames` mit eckigen Klammern. Da wir diese Zugriffe danach
erst einmal nicht weiter verwenden, kann dieser Abschnitt jedoch
zunächst problemlos übersprungen werden. Da Datenzugriffe mit eckigen
Klammern jedoch ein zentraler Bestandteil von `R` sind, lohnt es sich
diesen Abschnitt später zu konsultieren oder zum Nachschlagen zu
nutzen.

### Der `[[·]]`-Zugriff

Den `[[·]]`-Zugriff nutzen wir wie den `$`-Zugriff zum Auslesen
einzelner Spalten aus `data.frames`:

```{r}
mdf[["Item1"]] # dasselbe wie mdf$Item1
```

Hierbei wird der Spaltenname als ein-elementiger Vektor vom Typ
`character` angegeben -- also mit Anführungszeichen.  Die
Anführungszeichen sind hier notwendig, bei der `$`-Notation verwenden
wir hingegen keine Anführungszeichen. Das hat zur Folge, dass wir statt
der expliziten Angabe des Texts auch eine Variable übergeben können, die
einen ein-elementigen `character`-Vektor abgespeichert hat; dies ist mit
der `$`-Notation nicht möglich.

```{r}
spalte <- "Augenfarbe"
mdf[[spalte]]
```

Ebenso ist es möglich, der `[[·]]`-Klammerung eine Funktion zu
übergeben, die einen ein-elementigen Vektor vom Typ character ausgibt
-- etwa die Funktion `paste0`:

```{r}
mdf[[paste0("Item", 1)]]
```

Der `[[·]]`-Zugriff wird in Zusammenspiel mit der Funktion `paste0` noch
einmal interessant werden, wenn wir in [Kapitel 6](#schleifen) mit
*Schleifen* nacheinander auf beliebig viele Spalten von `data.frames`
zugreifen. In einer Schleife können wir dann Spaltennamen automatisiert
nacheinander austauschen (etwa: `Item_1`, `Item_2`, ...).

### Der `[·]`-Zugriff

**Nicht** äquivalent zu den Zugriffen mit `$` und `[[·]]` ist
folgender `[·]`-Zugriff:

```{r}
mdf["Item1"]
```

Auch hier sind Anführungszeichen zur Identifikation der auszuwählenden
Spalte nötig. Der Unterschied von `[·]` zu `[[·]]` und `$`: `[[·]]` und
`$` ergeben einen Vektor, `[·]` einen `data.frame` mit einer Spalte.
Außerdem können wir mit dem `[·]`-Zugriff gleichzeitig mehrere Spalten
auswählen, indem wir einen mehr-elementigen Vektor vom Typ `character`
angeben. Das war mit den Zugriffen per `[[·]]` und `$` nicht möglich,
die immer nur eine Spalte ausgeben. 

```{r}
mdf[c("Item1", "Augenfarbe")]
```

Dieser Aufruf sollte uns an die `[·,·]`-Notation zur Auswahl von Spalten
erinnern; in der ist der folgende Ausdruck äquivalent:

```{r}
mdf[, c("Item1", "Augenfarbe")]
```

Zwischen dem `[·]`-Zugriff und der `[·,·]`-Auswahl für Spalten gibt es
jedoch einen Unterschied, der zutage kommt, wenn wir nur eine Spalte
auswählen:

```{r}
mdf["Item1"]
```

```{r}
mdf[, "Item1"]
```

Hier gibt die `[·,·]`-Auswahl einen Vektor zurück und die `[·]`-Auswahl
einen `data.frame` mit nur einer Spalte. So lernen wir einen Sonderfall
der `[·,·]`-Auswahl kennen: Im Normalfall erhalten wir einen ganzen
`data.frame` zurück, wenn wir per `[·,·]` Daten anfordern. Wenn wir aber
nur eine Spalte anfordern, "reduziert" sich die Ausgabe zu einem Vektor.
Das liegt daran, dass eine einzelne Spalte eines `data.frame` auch gut
als Vektor repräsentiert ist.

## Zugriff auf Spalten und Zeilen: die Funktion `subset` {#subset}

**Ideen für Restrukturierung**

- subset = Abstraktion wichtiger Nutzungen von [·,·]: Spaltenauswahl per
  Spaltenname, Zeilenauswahl per logischem Ausdruck
- Dafür: Zeilenauswahl per logischem Ausdruck, Spaltenauswahl wie gehabt,
  aber mit Sonderregeln, die die Auswahl etwas vereinfachen
- Außerdem in diesem Abschnitt: Erklärung einiger allgemeiner Regeln
  zu Funktionen in R

**Von hier an überprüfen, was alles zum Abschnitt [·,·] gewechselt ist;
das hier rauslöschen und prüfen, was sonst bleiben soll**

Einzelne Spalten aus `data.frames` können wir mit dem `$`-Zugriff
auslesen. Wir lernen nun die Funktion `subset`[^`r incref()`] kennen,
mit der wir bequem beliebige Spalten und Zeilen aus `data.frames`
auswählen können. Anders als bei der Auswahl mit dem `$`-Operator --
dessen Rückgabe ein Vektor ist --, gibt uns die Funktion `subset` immer
einen ganzen `data.frame` zurück.

[^`r incfnc()`]: Der Abschnitt zur Funktion `subset` ist ein besonders
wichtiger Abschnitt, da hier nicht nur die spezielle Funktionalität
einer einzelnen Funktion erläutert wird, sondern auch an ihrem Beispiel
allgemeine Eigenschaften von Funktionen in `R` dargestellt werden.

Mit `subset` können wir beispielsweise nur eine Teilmenge aller Fälle
auswählen; etwa nur die Personen mit blauen Augen. Für diese Auswahl
hilft uns unser Wissen über logische Vergleiche aus dem letzten
Kapitel:[^`r incref()`]

[^`r incfnc()`]: Beachtet, dass durch diesen Aufruf die Tabelle
`mdf` nicht verändert wird. Die Funktion gibt stattdessen eine
neue Tabelle zurück, die nur die Fälle enthält, bei denen
`Augenfarbe == "blau"` gilt. Wir müssten das Ergebnis der Funktion in
einer Variablen speichern, wenn wir damit weiter arbeiten wollen
(Erinnerung: [Kapitel 2](#ausgabevsabspeichern)).

```{r}
subset(mdf, Augenfarbe == "blau")
```

Auf diese Weise haben wir mit einem logischen Vergleich aus der Tabelle
nur zwei Zeilen ausgewählt. Ihr merkt: In der Funktion `subset` kann ich
für die logische Auswahl nach Augenfarbe die Spalte `Augenfarbe` direkt
mit ihrem Namen adressieren, ohne dass ich die `$`-Notation
verwende. Das ist eine Besonderheit der Funktion `subset`; außerhalb der
Funktion würde der Befehl `Augenfarbe == "blau"` einen Fehler ausgeben,
da `Augenfarbe` selbst keine Variable ist -- nur eine Spalte von
`mdf`.[^`r incref()`] Innerhalb der Funktion `subset`
funktioniert es nur deswegen, da das erste Argument der `data.frame`
ist, aus dem ich Daten auswähle. Die Funktion `subset` weiß somit, auf
welchen Daten sie operieren muss. Das Folgende ist also nicht nötig,
obwohl es auch funktionieren würde:

[^`r incfnc()`]: Es macht an dieser Stelle Sinn, einen Moment inne zu
halten und zu überlegen, warum es eigentlich außergewöhnlich ist, dass
der Befehl `Augenfarbe == "blau"` innerhalb der Funktion `subset`
funktioniert.

```R
subset(mdf, mdf$Augenfarbe == "blau")
```

Dementsprechend könnte man auch der Funktion `subset` -- dieses
Verhalten kennen wir von der `[·]`-Notation zur Auswahl von Elementen
aus Vektoren -- einen beliebigen logischen Vektor zur Auswahl der Zeilen
übergeben:

```{r}
subset(mdf, c(TRUE, FALSE, FALSE, TRUE, FALSE)) # wählt die erste und vierte Zeile aus
```

Durch die UND bzw. ODER Operationen können wir auch komplexere
Anforderungen an die Auswahl stellen:

```{r}
subset(mdf, Augenfarbe == "blau" | Augenfarbe == "grün")

subset(mdf, (Augenfarbe == "blau" | Augenfarbe == "grün") & Item1 == 1)

```

Wie schon erwähnt, können wir mit `subset` nicht nur Zeilen, sondern
auch Spalten auswählen:

```{r}
subset(mdf, Augenfarbe == "blau", c("Item1", "Augenfarbe"))
```

Hierbei habe ich mit dem dritten Argument `c('Item1', 'Augenfarbe')`
eine Auswahl der Spalten durchgeführt. Dazu habe ich einen Vektor vom
Typ `character` übergeben, der die auszulesenden Spalten mit Namen
adressiert. Durch die Kombination der Auswahl von Zeilen und Spalten
wird mir insgesamt ein `data.frame` ausgegeben, der nur die Spalten
"Item1" und "Augenfarbe" enthält, und diese nur für Personen mit blauen
Augen.

```{block, type = "block"}
**Merke**: Die Funktion `subset` gibt immer einen ganzen `data.frame`
zurück -- selbst dann, wenn ich nur eine einzige Spalte anfordere. Mit
dem `$`-Operator könnte ich hingegen eine einzelne Spalte als Vektor
auslesen.
```

Bei dieser Verwendung der Funktion `subset` fällt eine allgemeine
Eigenschaft von Funktionen auf: `subset` erkennt anhand der Reihenfolge
der Argumente, wie sie sich zu verhalten hat. Das erste Argument
übergibt den `data.frame`, von dem wir Daten anfordern. Das zweite
Argument wählt mit einem logischen Ausdruck **Zeilen** aus, das dritte
Argument wählt durch einem `character`-Vektor **Spalten** aus. Was
passiert, wenn wir diese Reihenfolge ändern?

```R
subset(mdf, c("Item1", "Augenfarbe"),
       Augenfarbe == "blau")
```

```
Fehler in subset.data.frame(mdf,
c("Item1", "Augenfarbe"), Augenfarbe ==  : 'subset' muss
boolesch sein
```

Hier erhalten wir eine schwierig zu verstehende Fehlermeldung. Aber uns
ist der Fehler klar: das zweite Argument von `subset` muss die Auswahl
der Zeilen beschreiben, wir haben aber stattdessen einen
`character`-Vektor übergeben, der die Spalten auswählen sollte. Was
können wir machen, wenn wir **nur** eine Auswahl nach Spalte ausführen
wollen? Wir können das zweite Argument ja nicht leer lassen, denn das
führt zum obigen Fehler.

Dieses Problem lässt sich mit einer praktischen Eigenschaft der
`R`-Sprache lösen: **In `R` haben die Argumente von Funktionen Namen.**
Bislang haben wir das ignoriert bzw. nur am Rande mitbekommen (erinnern
wir uns an das Argument `na.rm` der Funktion `mean`).

Die Funktion `subset` hat die folgenden drei benannten Argumente:

- `x`: der Datensatz, aus dem ausgewählt wird
- `subset`: die Auswahl der Zeilen
- `select`: die Auswahl der Spalten

Um eine Übersicht über die verschiedenen Argumente einer Funktion zu
erhalten, können wir die eingebaute Hilfe von `R` verwenden, die wir mit
dem `?`-Operator erhalten. Wir verwenden sie wie folgt:

```R
?subset
```

Die `R`-Hilfe informiert uns unter anderem über die Argumente, die
Funktionen annehmen können. Leider ist diese Hilfe oftmals kryptisch --
und das nicht nur für Anfänger. Sie ist die offizielle Dokumentation von
Funktionen und legt deswegen zwar großen Wert auf technische
Genauigkeit, ist aber nicht immer sonderlich ausführlich oder gar
verständlich. Wir werden in Kapitel 5 bei einer ausführlicheren
Besprechung von Funktionen noch einmal darauf zurückkommen, wie wir mit
der Hilfe-Funktion umgehen können.

Wenn wir die verschiedenen Argumente der Funktion `subset` kennen,
können wir sie auch mit der folgenden Notation ausführen:

```{r}
subset(x = mdf, subset = Augenfarbe == "blau",
       select = c("Item1", "Augenfarbe"))
```

Hierbei benennen wir die Argumente, die wir nutzen, explizit.  Wie wir
es schon beim Argument `na.rm` der Funktion `mean` kennengelernt haben,
können wir Argumente mit der Schreibweise "`Funktionsargument = Wert`"
adressieren. "`Wert`" ist dabei immer ein `R`-Objekt,
"`Funktionsargument`" der Name des Arguments. Im Fall von `subset`
nehmen die drei Argumente folgende Objekte an:[^`r incref()`]

[^`r incfnc()`]: Die Funktion `subset` lässt hier ein paar Ausnahmen zu,
die weiter unten besprochen werden. Die erste Ausnahme kennen wir schon:
Das Argument `subset` akzeptiert auch, wenn wir einen Ausdruck
übergeben, der außerhalb der Funktion gar nicht als logischer Vektor
erkannt würde.

1. `x`: einen `data.frame`
2. `subset`: einen logischer Vektor
3. `select`: einen Vektor vom Typ `character`

Wenn ich Funktionsargumente mit Namen adressiere, kann ich die
Reihenfolge, in der ich sie der Funktion übergebe, beliebig
vertauschen. Dieser Aufruf etwa ist äquivalent (d.h. führt zur selben
Ausgabe) wie der obige Aufruf:


```R
subset(select = c("Item1", "Augenfarbe"),
       subset = Augenfarbe == "blau", x = mdf)
```


```{r, echo = FALSE}
## doppelter Code wegen Formatierung =/
subset(select = c("Item1", "Augenfarbe"),
       subset = Augenfarbe == "blau", x = mdf)
```

In `R` kann man **fast immer**[^`r incref()`] Argumente per Position und
per Name ansprechen. Oftmals wollen wir die Namen von Funktionen
explizit verwenden, da viele Funktionen *optionale* Argumente haben --
also solche, die wir nicht immer angeben müssen. Wir können ja
beispielsweise das Argument `select` weglassen, wenn wir nach Zeilen,
aber nicht nach Spalten selegieren wollen. Analog muss ich nicht das
Argument `subset` angeben -- in dem Fall werden alle Zeilen ausgegeben,
aber nur eine Teilmenge der Spalten, wie in diesem Beispiel:

[^`r incfnc()`]: Eine Ausnahme bildet hier die Funktion `c`, bei der wir
keine Funktionsnamen angeben. Hier gilt nämlich: wir können beliebig
viele Vektoren als Argumente angeben und deswegen gibt es natürlich
keinen separaten Namen für jedes mögliche Argument. Feste Namen gibt es
aber normalerweise, wenn es eine feste Anzahl an möglichen Argumenten
gibt -- wie bei der Funktion `subset`.

```{r}
subset(mdf, select = c("Testscore", "Geschlecht"))
```

Mit diesem Aufruf werden mir alle 5 Fälle zurückgegeben, aber für diese
nur der Testscore und das Geschlecht. Wie dieser Aufruf zeigt, kann ich
Auswahl nach Position und Auswahl nach Namen mischen. Für das erste
Argument -- `mdf` -- habe ich den Argumentnamen `x` nicht
angegeben. Daher wurde das Argument anhand der Position
identifiziert. Das hat funktioniert, da das erste Argument der
`data.frame` ist, aus dem die Datenauswahl stattfindet. Für die Auswahl
der Spalten habe ich jedoch den Argumentnamen angegeben. **Das war auch
nötig**, da `subset` als zweites Argument sonst die Auswahl der Zeilen
erwartet hätte.

```{block, type = "block"}
**Merke**: In `R` können Funktionsargumente per Position und per Namen
identifiziert werden. Die Identifikation per Name schlägt dabei die
Identifikation per Position.
```

**Ausnahmeregeln für die Funktion `subset`**

Inhalt folgt.

### Zugriff nach Name und Index {#nameindex}

Nachdem die Möglichkeiten zum Zugriff auf `data.frames` besprochen sind,
stellen wir zum Abschluss ein grundsätzliches Prinzip zu Datenzugriffen
in `R` fest: Man kann Zugriffe -- seien es Vektoren, `data.frames` oder
auch andere Strukturen, die wir noch gar nicht behandelt haben -- **nach
Index oder nach Name** durchführen. Wir haben bereits Beispiele für
beides kennengelernt: In Vektoren haben wir Zugriffe mithilfe von
Indexen durchgeführt, indem wir (a) die Position von auszuwählenden
Elementen explizit mit einem numerischen Vektor angegeben haben, oder
(b) indem wir einen logischen Vektor übergeben haben, der anhand von
`TRUE` und `FALSE` Werten die Indexe auswählt, deren Elemente ausgegeben
werden sollen. Der Vollständigkeit halber sei hier mitgeteilt, dass man
sogar bei Vektoren Zugriffe nach Namen durchführen kann, wenn die
Elemente des Vektors benannt sind. Das ist gar nicht so ungewöhnlich;
wie folgt könnte man einen Vektor mit benannten Elementen erstellen und
mit der bekannten `[·]`-Notation darauf zugreifen.

```{r}

## Benannte Vektoren erstellen funktioniert wie einen data.frame zu
## erstellen:
vec <- c(foo = 1, bar = 2)
vec

vec["foo"]
vec["bar"]
vec[c("bar", "foo")]

```

In `data.frames` haben wir Spalten zumeist nach Namen ausgewählt:
- Mit der `$`-Notation
- Mit der `[·,·]`-Notation
- Mit der Funktion `subset`
- Mit der `[[·]]`-Notation
- Mit der `[·]`-Notation

 Mit der `[·,·]`-Notation können wir in `data.frames` zusätzlich auch
 Zugriffe nach numerischem oder logischen Index durchführen, wie wir
 gesehen haben. Dabei kann die Auswahl sowohl nach Spalten als auch nach
 Zeilen -- oder beidem -- geschehen.

## Nützliche Funktionen zum Arbeiten mit `data.frames` {#convenient}

### `tapply` {#tapply}

Die Funktion `tapply` kann ich verwenden, um mir deskriptive
Statistiken anhand von Gruppierungsvariablen ausgeben zu lassen, hier
etwa die mittlere Punktzahl oder das mittlere Alter nach Geschlecht der
Schüler/innen:

```{r}
tapply(mdf$Testscore, mdf$Geschlecht, mean)
tapply(mdf$Alter, mdf$Geschlecht, mean)
```

Die Funktion `tapply` erhält als erstes Argument den Messwertvektor, für
den Statistiken angefordert werden. Das zweite Argument ist die
Gruppierungsvariable.[^`r incref()`] Interessanterweise ist das dritte
Argument eine Funktion, in diesem Fall die Funktion `mean`. So können
wir die *mittlere* Punktzahl nach Geschlecht anfordern. Entsprechend
könnten wir hier andere Funktionen übergeben, um etwa die
Standardabweichung des Alters zu erfragen:

[^`r incfnc()`]: Beachtet, dass sowohl Messwerte als auch
Gruppierungsvariable als **Vektoren** übergeben werden. Ich behandle die
Funktion `tapply` jedoch im Kapitel zu `data.frames`, da es zumeist so
sein wird, dass wir beide Vektoren aus **einem** `data.frame` mit der
`$`-Notation auslesen werden.

```{r}
tapply(mdf$Alter, mdf$Geschlecht, sd)
```

Wie `table` kann auch `tapply` deskriptive Statistiken anhand mehrerer
Gruppierungsvariablen anfordern. Um mehrere Gruppierungsvariablen
anzufordern, klammern wir `list(...)` um die Gruppierungsvektoren im
zweiten Argument:

```{r}
tapply(mdf$Alter, list(mdf$Geschlecht, mdf$Augenfarbe), mean)
```

Mit nur fünf Datenpunkten macht diese Anfrage hier nur wenig Sinn, da
jeder ausgegebene Mittelwert nur anhand eines einzelnen Wertes gebildet
wurde,[^`r incref()`] was die Idee des Mittelwerts eher ad absurdum
führt. Manche Kombinationen von Geschlecht und Augenfarbe kommen in
unseren Daten sogar gar nicht vor; in diesen Fällen wird `NA`
ausgegeben. `tapply` zeigt ihre Stärke vor allem, wenn man viele -- und
nicht nur 5 -- Datenpunkte hat. Das gilt gerade dann, wenn wir mehrere
Gruppierungsvariablen angeben.

[^`r incfnc()`]: Wie viele Datenpunkte in die Berechnung jedes
Mittelwerts eingehen, können wir in diesem Fall prüfen mit
`table(mdf$Geschlecht, mdf$Augenfarbe)`.

### `nrow` und `ncol`

Die Zahl der Zeilen eines `data.frame`s -- d.h. oftmals die Zahl der
*Fälle* -- lässt sich mit der Funktion `nrow` bestimmen, die man sehr
häufig verwendet:

```{r}
nrow(mdf)
```

Analog ergibt `ncol` die Zahl der Spalten:

```{r}
ncol(mdf)
```

### `head` und `tail`

Um sich einen Überblick über einen `data.frame` zu verschaffen, sind die
Funktionen `head` und `tail` sehr nützlich. `head` gibt die ersten
Zeilen eines `data.frames` zurück, `tail` entsprechend die letzten
Zeilen. Beide Funktionen haben ein zweites Argument *n*, welches wir
nutzen können, um zu steuern, wie viele Zeilen ausgegeben werden
sollen. Wenn wir *n* nicht angeben, werden 6 Zeilen ausgegeben (in
`R`-Jargon: 6 ist der "default"-, also Standardwert des *optionalen
Arguments* n). Beispiel:

```{r}
head(mdf, n = 2)
tail(mdf)
```

Im letzteren Fall werden einfach alle Zeilen zurückgegeben, da unser
`data.frame` insgesamt nur fünf Zeilen hat -- und somit weniger als 6.

### Sortieren: `dplyr::arrange`

Oftmals wollen wir Datentabellen nach einer oder mehreren Variablen
sortieren. Dies funktioniert am bequemsten, wenn wir das *Paket* `dplyr`
laden [@R-dplyr]:

```{r}
library("dplyr")
```

Voraussetzung dafür, dass ich das Paket `dplyr` nutzen kann ist, dass
ich das Paket auf meinem Rechner installiert habe. Falls das Paket noch
nicht installiert ist (in dem Fall ergibt der Befehl `library('dyplr')`
einen Fehler) , könnte ich es mit dem folgenden Befehl installieren:

```R
install.packages("dplyr")
```

Pakete stellen zusätzliche Funktionen zur Verfügung, die in der
Basisversion von `R` nicht enthalten sind. Um ein Paket zu nutzen,
müssen wir es mit der Funktion `library` in unsere `R`-Umgebung laden.
Andernfalls könnten wir die Funktionen nicht nutzen, die etwa `dplyr`
enthält. Die Funktion `arrange` aus `dplyr` ermöglicht es uns, einen
`data.frame` zu sortieren:

```{r}
arrange(mdf, Testscore) # dplyr muss geladen sein
```

In der Funktion `arrange` geben wir als erstes Argument den zu
sortierenden `data.frame` an. Darauf folgen -- mit Komma separiert --
alle Spalten nach denen wir sortieren wollen (hier erst mal nur der
Testscore). Standardmäßig sortiert `arrange` *aufsteigend*, wenn wir
eine absteigende Sortierung wünschen, müssen wir ein Minus vor die
Sortierspalte setzen:

```{r}
arrange(mdf, -Testscore)
```

Es ist auch möglich, nach mehreren Spalten zu sortieren. In dem Fall
wird bei gleichen Werten im ersten Sortierkriterium anhand des nächsten
Kriteriums die Reihenfolge entschieden. Wir könnten etwa unsere Daten
nach Geschlecht sortieren, und innerhalb der Personen gleichen
Geschlechts nach Punktzahl:

```{r}
arrange(mdf, Geschlecht, -Testscore)
```

## Zusammenfassung

- Wir haben den `data.frame` als Datenstruktur zur Speicherung von
  psychometrischen Daten kennengelernt
- Wir haben den Zugriff auf Spalten und Zeilen in `data.frames` mit der
  `$`-Notation und der Funktion `subset` kennengelernt
- Zur Anforderung von deskriptiven Statistiken können wir die Funktionen
  `table` und `tapply` verwenden
- Wir haben weitere Funktionen kennengelernt, die uns einen Überblick
  über `data.frames` verschaffen:
    + `names`
    + `nrow/ncol`
    + `head/tail`
    + `dplyr::arrange`

## Fragen zum vertiefenden Verständnis

1. Worin unterscheiden sich die folgenden Aufrufe? Welche Aufrufe sind
   zueinander äquivalent?

```R
subset(mdf, select = "Item1")
```

```R
mdf[, "Item1"]
```

```R
mdf[, "Item1", drop = FALSE]
```

```R
mdf[["Item1"]]
```

```R
mdf$Item1
```

2. Vergleicht die folgenden Aufrufe der Funktion `subset`. Warum
   funktionieren der erste und der zweite Aufruf, aber nicht der dritte
   und vierte?  Wie kann es überhaupt sein, dass die ersten beiden
   Funktionsaufrufe funktionieren, obwohl Argumente unbenannt an der
   "falschen" Position stehen?

```R
subset(mdf, select = "Item1", Augenfarbe == "blau")
```

```R
subset(select = "Item1", mdf, Augenfarbe == "blau")
```

```R
subset(mdf, "Item1", Augenfarbe == "blau")
```

```R
subset("Item1", mdf, Augenfarbe == "blau")
```
